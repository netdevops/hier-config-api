{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"hier-config-api","text":"<p>A comprehensive REST API for hier_config network configuration management.</p>"},{"location":"#overview","title":"Overview","text":"<p>hier-config-api provides a FastAPI-based REST interface to the powerful hier_config library, enabling network engineers and automation tools to:</p> <ul> <li>Compare and Diff: Analyze differences between running and intended configurations</li> <li>Generate Remediation: Automatically create commands to achieve desired state</li> <li>Multi-Device Analysis: Aggregate and analyze changes across device fleets</li> <li>Platform Support: Work with Cisco IOS/NX-OS/IOS-XR, Juniper Junos, Arista EOS, and more</li> <li>Batch Processing: Handle multiple devices in parallel for efficiency</li> <li>Flexible Export: Output results in JSON, CSV, or YAML formats</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#configuration-operations","title":"Configuration Operations","text":"<p>Parse, compare, merge, and search network configurations across different platforms.</p>"},{"location":"#remediation-workflows","title":"Remediation Workflows","text":"<p>Generate precise remediation and rollback configurations with tag-based filtering for safe, incremental deployments.</p>"},{"location":"#multi-device-reporting","title":"Multi-Device Reporting","text":"<p>Create comprehensive reports showing configuration drift and changes across your entire network infrastructure.</p>"},{"location":"#restful-architecture","title":"RESTful Architecture","text":"<p>Clean, well-documented REST API with automatic OpenAPI/Swagger documentation.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Generate remediation for a configuration change\ncurl -X POST http://localhost:8000/api/v1/remediation/generate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platform\": \"cisco_ios\",\n    \"running_config\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\",\n    \"intended_config\": \"hostname router2\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.2 255.255.255.0\"\n  }'\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Installation Guide to get up and running quickly, or jump to the Quick Start for a hands-on introduction.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>hier-config-api follows a clean, layered architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         REST API Layer              \u2502\n\u2502      (FastAPI Routers)              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Service Layer                 \u2502\n\u2502    (Business Logic)                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      Pydantic Models                \u2502\n\u2502  (Validation &amp; Serialization)       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      hier_config Library            \u2502\n\u2502  (Core Configuration Logic)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<ul> <li>Cisco IOS</li> <li>Cisco NX-OS</li> <li>Cisco IOS-XR</li> <li>Juniper Junos</li> <li>Arista EOS</li> <li>Generic</li> </ul>"},{"location":"#why-hier-config-api","title":"Why hier-config-api?","text":"<ul> <li>Production Ready: Comprehensive test suite, type hints, and linting</li> <li>Well Documented: Automatic API docs, examples, and guides</li> <li>Flexible: RESTful design works with any programming language or tool</li> <li>Scalable: Stateless design with batch processing for large deployments</li> <li>Standards-Based: OpenAPI/Swagger for easy integration</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! See the Contributing Guide for details on how to get involved.</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE for details.</p>"},{"location":"api/batch/","title":"Batch Operations","text":"<p>Process multiple devices in parallel for improved efficiency.</p>"},{"location":"api/batch/#create-batch-remediation-job","title":"Create Batch Remediation Job","text":"<p>Create a batch job to generate remediation for multiple devices.</p> <p>Endpoint: <code>POST /api/v1/batch/remediation</code></p>"},{"location":"api/batch/#request","title":"Request","text":"<pre><code>{\n  \"device_configs\": [\n    {\n      \"device_id\": \"router1\",\n      \"platform\": \"cisco_ios\",\n      \"running_config\": \"hostname router1\",\n      \"intended_config\": \"hostname router1-new\"\n    },\n    {\n      \"device_id\": \"router2\",\n      \"platform\": \"cisco_ios\",\n      \"running_config\": \"hostname router2\",\n      \"intended_config\": \"hostname router2-new\"\n    },\n    {\n      \"device_id\": \"switch1\",\n      \"platform\": \"cisco_nxos\",\n      \"running_config\": \"hostname switch1\",\n      \"intended_config\": \"hostname switch1-new\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/batch/#response","title":"Response","text":"<pre><code>{\n  \"job_id\": \"job-abc-123-def-456\",\n  \"total_devices\": 3\n}\n</code></pre>"},{"location":"api/batch/#get-batch-job-status","title":"Get Batch Job Status","text":"<p>Get the current status and progress of a batch job.</p> <p>Endpoint: <code>GET /api/v1/batch/jobs/{job_id}</code></p>"},{"location":"api/batch/#response_1","title":"Response","text":"<pre><code>{\n  \"job_id\": \"job-abc-123-def-456\",\n  \"status\": \"completed\",\n  \"progress\": 100.0,\n  \"total_devices\": 3,\n  \"completed_devices\": 3,\n  \"failed_devices\": 0\n}\n</code></pre> Field Type Description job_id string Unique job identifier status string Job status (pending, running, completed, failed) progress float Progress percentage (0-100) total_devices integer Total number of devices completed_devices integer Successfully processed devices failed_devices integer Failed devices"},{"location":"api/batch/#status-values","title":"Status Values","text":"<ul> <li><code>pending</code> - Job created, not yet started</li> <li><code>running</code> - Job is currently processing</li> <li><code>completed</code> - Job finished successfully</li> <li><code>failed</code> - Job encountered fatal error</li> </ul>"},{"location":"api/batch/#get-batch-job-results","title":"Get Batch Job Results","text":"<p>Get the results of a completed batch job.</p> <p>Endpoint: <code>GET /api/v1/batch/jobs/{job_id}/results</code></p>"},{"location":"api/batch/#response_2","title":"Response","text":"<pre><code>{\n  \"job_id\": \"job-abc-123-def-456\",\n  \"status\": \"completed\",\n  \"results\": [\n    {\n      \"device_id\": \"router1\",\n      \"status\": \"success\",\n      \"remediation\": \"no hostname router1\\nhostname router1-new\",\n      \"rollback\": \"no hostname router1-new\\nhostname router1\"\n    },\n    {\n      \"device_id\": \"router2\",\n      \"status\": \"success\",\n      \"remediation\": \"no hostname router2\\nhostname router2-new\",\n      \"rollback\": \"no hostname router2-new\\nhostname router2\"\n    },\n    {\n      \"device_id\": \"switch1\",\n      \"status\": \"failed\",\n      \"error\": \"Configuration parsing error\"\n    }\n  ],\n  \"summary\": {\n    \"total_devices\": 3,\n    \"completed_devices\": 2,\n    \"failed_devices\": 1,\n    \"status\": \"completed\"\n  }\n}\n</code></pre>"},{"location":"api/batch/#workflow-example","title":"Workflow Example","text":""},{"location":"api/batch/#1-submit-batch-job","title":"1. Submit Batch Job","text":"<pre><code>import requests\nimport time\n\n# Prepare device list\ndevices = []\nfor i in range(100):\n    devices.append({\n        \"device_id\": f\"router{i}\",\n        \"platform\": \"cisco_ios\",\n        \"running_config\": f\"hostname router{i}\",\n        \"intended_config\": f\"hostname router{i}-new\"\n    })\n\n# Create batch job\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/batch/remediation\",\n    json={\"device_configs\": devices}\n)\n\njob_id = response.json()[\"job_id\"]\nprint(f\"Job created: {job_id}\")\n</code></pre>"},{"location":"api/batch/#2-monitor-progress","title":"2. Monitor Progress","text":"<pre><code># Poll for completion\nwhile True:\n    status = requests.get(\n        f\"http://localhost:8000/api/v1/batch/jobs/{job_id}\"\n    ).json()\n\n    print(f\"Progress: {status['progress']:.1f}% \"\n          f\"({status['completed_devices']}/{status['total_devices']})\")\n\n    if status['status'] in ['completed', 'failed']:\n        break\n\n    time.sleep(2)\n</code></pre>"},{"location":"api/batch/#3-get-results","title":"3. Get Results","text":"<pre><code># Fetch results\nresults = requests.get(\n    f\"http://localhost:8000/api/v1/batch/jobs/{job_id}/results\"\n).json()\n\n# Process successful remediations\nfor result in results['results']:\n    if result['status'] == 'success':\n        print(f\"{result['device_id']}: Ready for deployment\")\n        print(result['remediation'])\n    else:\n        print(f\"{result['device_id']}: FAILED - {result['error']}\")\n</code></pre>"},{"location":"api/batch/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/batch/#batch-size","title":"Batch Size","text":"<p>Optimal batch size depends on:</p> <ul> <li>Server resources (CPU, memory)</li> <li>Configuration complexity</li> <li>Network latency</li> </ul> <p>Recommended batch sizes:</p> <ul> <li>Small configs (&lt;100 lines): 100-500 devices</li> <li>Medium configs (100-1000 lines): 50-100 devices</li> <li>Large configs (&gt;1000 lines): 10-50 devices</li> </ul>"},{"location":"api/batch/#timeouts","title":"Timeouts","text":"<p>For large batches, consider:</p> <ul> <li>Increasing server timeout settings</li> <li>Splitting into smaller batches</li> <li>Using asynchronous processing</li> </ul>"},{"location":"api/batch/#error-handling","title":"Error Handling","text":"<p>Batch jobs continue processing even if individual devices fail. Always check the <code>failed_devices</code> count and review the error messages in the results.</p>"},{"location":"api/configurations/","title":"Configuration Operations","text":"<p>Endpoints for parsing, comparing, and manipulating network configurations.</p>"},{"location":"api/configurations/#parse-configuration","title":"Parse Configuration","text":"<p>Parse raw configuration text into a structured format.</p> <p>Endpoint: <code>POST /api/v1/configs/parse</code></p>"},{"location":"api/configurations/#request","title":"Request","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"config_text\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\"\n}\n</code></pre> Field Type Required Description platform string Yes Platform type (cisco_ios, cisco_nxos, etc.) config_text string Yes Raw configuration text"},{"location":"api/configurations/#response","title":"Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"structured_config\": {\n    \"text\": \"hostname router1\",\n    \"children\": [\n      {\n        \"text\": \"interface GigabitEthernet0/0\",\n        \"children\": [\n          {\n            \"text\": \"ip address 192.168.1.1 255.255.255.0\",\n            \"children\": []\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"api/configurations/#example","title":"Example","text":"<pre><code>curl -X POST http://localhost:8000/api/v1/configs/parse \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platform\": \"cisco_ios\",\n    \"config_text\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\"\n  }'\n</code></pre>"},{"location":"api/configurations/#compare-configurations","title":"Compare Configurations","text":"<p>Compare running and intended configurations to identify differences.</p> <p>Endpoint: <code>POST /api/v1/configs/compare</code></p>"},{"location":"api/configurations/#request_1","title":"Request","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"running_config\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\",\n  \"intended_config\": \"hostname router2\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.2 255.255.255.0\"\n}\n</code></pre> Field Type Required Description platform string Yes Platform type running_config string Yes Current configuration intended_config string Yes Desired configuration"},{"location":"api/configurations/#response_1","title":"Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"unified_diff\": \"--- running_config\\n+++ intended_config\\n+ no hostname router1\\n+ hostname router2\\n- no hostname router2\\n- hostname router1\",\n  \"has_changes\": true\n}\n</code></pre> Field Type Description platform string Platform type unified_diff string Unified diff output has_changes boolean Whether differences exist"},{"location":"api/configurations/#predict-configuration","title":"Predict Configuration","text":"<p>Predict the future configuration state after applying commands.</p> <p>Endpoint: <code>POST /api/v1/configs/predict</code></p>"},{"location":"api/configurations/#request_2","title":"Request","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"current_config\": \"hostname router1\",\n  \"commands_to_apply\": \"interface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\"\n}\n</code></pre>"},{"location":"api/configurations/#response_2","title":"Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"predicted_config\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\"\n}\n</code></pre>"},{"location":"api/configurations/#merge-configurations","title":"Merge Configurations","text":"<p>Merge multiple configuration snippets into a single configuration.</p> <p>Endpoint: <code>POST /api/v1/configs/merge</code></p>"},{"location":"api/configurations/#request_3","title":"Request","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"configs\": [\n    \"hostname router1\",\n    \"interface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\",\n    \"interface GigabitEthernet0/1\\n ip address 192.168.2.1 255.255.255.0\"\n  ]\n}\n</code></pre>"},{"location":"api/configurations/#response_3","title":"Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"merged_config\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\\ninterface GigabitEthernet0/1\\n ip address 192.168.2.1 255.255.255.0\"\n}\n</code></pre>"},{"location":"api/configurations/#search-configuration","title":"Search Configuration","text":"<p>Search configuration for lines matching specific patterns.</p> <p>Endpoint: <code>POST /api/v1/configs/search</code></p>"},{"location":"api/configurations/#request_4","title":"Request","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"config_text\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\\ninterface GigabitEthernet0/1\\n ip address 192.168.2.1 255.255.255.0\",\n  \"match_rules\": {\n    \"contains\": \"interface\"\n  }\n}\n</code></pre>"},{"location":"api/configurations/#match-rules","title":"Match Rules","text":"Field Type Description equals string Exact match contains string Substring match startswith string Prefix match regex string Regular expression"},{"location":"api/configurations/#response_4","title":"Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"matches\": [\n    \"interface GigabitEthernet0/0\",\n    \"interface GigabitEthernet0/1\"\n  ],\n  \"match_count\": 2\n}\n</code></pre>"},{"location":"api/configurations/#examples","title":"Examples","text":"<p>Search for interfaces:</p> <pre><code>curl -X POST http://localhost:8000/api/v1/configs/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platform\": \"cisco_ios\",\n    \"config_text\": \"...\",\n    \"match_rules\": {\n      \"startswith\": \"interface\"\n    }\n  }'\n</code></pre> <p>Search using regex:</p> <pre><code>curl -X POST http://localhost:8000/api/v1/configs/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platform\": \"cisco_ios\",\n    \"config_text\": \"...\",\n    \"match_rules\": {\n      \"regex\": \"ip address \\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\"\n    }\n  }'\n</code></pre>"},{"location":"api/overview/","title":"API Overview","text":"<p>The hier-config-api provides a comprehensive REST API for network configuration management.</p>"},{"location":"api/overview/#base-url","title":"Base URL","text":"<p>All API endpoints are prefixed with <code>/api/v1/</code>:</p> <pre><code>http://localhost:8000/api/v1/\n</code></pre>"},{"location":"api/overview/#authentication","title":"Authentication","text":"<p>Currently, the API does not require authentication. For production deployments, consider adding:</p> <ul> <li>API keys</li> <li>OAuth2/JWT tokens</li> <li>IP allowlisting</li> </ul>"},{"location":"api/overview/#response-format","title":"Response Format","text":"<p>All responses are in JSON format with appropriate HTTP status codes.</p>"},{"location":"api/overview/#success-response","title":"Success Response","text":"<pre><code>{\n  \"field1\": \"value1\",\n  \"field2\": \"value2\"\n}\n</code></pre>"},{"location":"api/overview/#error-response","title":"Error Response","text":"<pre><code>{\n  \"detail\": \"Error message describing what went wrong\"\n}\n</code></pre>"},{"location":"api/overview/#http-status-codes","title":"HTTP Status Codes","text":"Code Description 200 Success 400 Bad Request - Invalid input 404 Not Found - Resource doesn't exist 422 Validation Error - Invalid request body 500 Internal Server Error"},{"location":"api/overview/#api-categories","title":"API Categories","text":""},{"location":"api/overview/#configuration-operations","title":"Configuration Operations","text":"<p>Endpoints for parsing, comparing, and manipulating configurations:</p> <ul> <li><code>POST /api/v1/configs/parse</code> - Parse configuration</li> <li><code>POST /api/v1/configs/compare</code> - Compare configurations</li> <li><code>POST /api/v1/configs/predict</code> - Predict future state</li> <li><code>POST /api/v1/configs/merge</code> - Merge configurations</li> <li><code>POST /api/v1/configs/search</code> - Search configuration</li> </ul> <p>Learn more \u2192</p>"},{"location":"api/overview/#remediation-workflows","title":"Remediation Workflows","text":"<p>Generate and manage remediation configurations:</p> <ul> <li><code>POST /api/v1/remediation/generate</code> - Generate remediation</li> <li><code>POST /api/v1/remediation/{id}/tags</code> - Apply tags</li> <li><code>GET /api/v1/remediation/{id}/filter</code> - Filter by tags</li> </ul> <p>Learn more \u2192</p>"},{"location":"api/overview/#multi-device-reports","title":"Multi-Device Reports","text":"<p>Create and analyze fleet-wide configuration reports:</p> <ul> <li><code>POST /api/v1/reports</code> - Create report</li> <li><code>GET /api/v1/reports/{id}/summary</code> - Get summary</li> <li><code>GET /api/v1/reports/{id}/changes</code> - Get changes</li> <li><code>GET /api/v1/reports/{id}/export</code> - Export report</li> </ul> <p>Learn more \u2192</p>"},{"location":"api/overview/#platform-information","title":"Platform Information","text":"<p>Platform-specific information and validation:</p> <ul> <li><code>GET /api/v1/platforms</code> - List platforms</li> <li><code>GET /api/v1/platforms/{platform}/rules</code> - Get rules</li> <li><code>POST /api/v1/platforms/{platform}/validate</code> - Validate config</li> </ul> <p>Learn more \u2192</p>"},{"location":"api/overview/#batch-operations","title":"Batch Operations","text":"<p>Process multiple devices in parallel:</p> <ul> <li><code>POST /api/v1/batch/remediation</code> - Create batch job</li> <li><code>GET /api/v1/batch/jobs/{id}</code> - Get job status</li> <li><code>GET /api/v1/batch/jobs/{id}/results</code> - Get results</li> </ul> <p>Learn more \u2192</p>"},{"location":"api/overview/#interactive-documentation","title":"Interactive Documentation","text":"<p>The API provides automatic interactive documentation:</p> <ul> <li>Swagger UI: http://localhost:8000/api/docs</li> <li>ReDoc: http://localhost:8000/api/redoc</li> </ul> <p>These interfaces allow you to:</p> <ul> <li>Browse all available endpoints</li> <li>View request/response schemas</li> <li>Test endpoints directly from the browser</li> <li>Generate example requests</li> </ul>"},{"location":"api/overview/#rate-limiting","title":"Rate Limiting","text":"<p>Currently, there is no rate limiting. For production deployments, consider implementing rate limiting at:</p> <ul> <li>Application level (using FastAPI middleware)</li> <li>Reverse proxy level (Nginx, Traefik)</li> <li>API gateway level (Kong, Tyk)</li> </ul>"},{"location":"api/overview/#pagination","title":"Pagination","text":"<p>Currently, endpoints return all results. Future versions will support pagination for large result sets:</p> <pre><code>GET /api/v1/reports/{id}/changes?page=1&amp;page_size=50\n</code></pre>"},{"location":"api/overview/#versioning","title":"Versioning","text":"<p>The API uses URL-based versioning (<code>/api/v1/</code>). Breaking changes will result in a new version (<code>/api/v2/</code>), while the old version remains available for backward compatibility.</p>"},{"location":"api/platforms/","title":"Platform Information","text":"<p>Get platform-specific information and validate configurations.</p>"},{"location":"api/platforms/#list-platforms","title":"List Platforms","text":"<p>Get a list of all supported platforms.</p> <p>Endpoint: <code>GET /api/v1/platforms</code></p>"},{"location":"api/platforms/#response","title":"Response","text":"<pre><code>[\n  {\n    \"platform_name\": \"cisco_ios\",\n    \"display_name\": \"Cisco IOS\",\n    \"vendor\": \"Cisco\",\n    \"supported\": true\n  },\n  {\n    \"platform_name\": \"cisco_nxos\",\n    \"display_name\": \"Cisco NX-OS\",\n    \"vendor\": \"Cisco\",\n    \"supported\": true\n  },\n  {\n    \"platform_name\": \"cisco_iosxr\",\n    \"display_name\": \"Cisco IOS-XR\",\n    \"vendor\": \"Cisco\",\n    \"supported\": true\n  },\n  {\n    \"platform_name\": \"juniper_junos\",\n    \"display_name\": \"Juniper Junos\",\n    \"vendor\": \"Juniper\",\n    \"supported\": true\n  },\n  {\n    \"platform_name\": \"arista_eos\",\n    \"display_name\": \"Arista EOS\",\n    \"vendor\": \"Arista\",\n    \"supported\": true\n  }\n]\n</code></pre>"},{"location":"api/platforms/#get-platform-rules","title":"Get Platform Rules","text":"<p>Get platform-specific configuration rules.</p> <p>Endpoint: <code>GET /api/v1/platforms/{platform}/rules</code></p>"},{"location":"api/platforms/#example","title":"Example","text":"<pre><code>curl http://localhost:8000/api/v1/platforms/cisco_ios/rules\n</code></pre>"},{"location":"api/platforms/#response_1","title":"Response","text":"<pre><code>{\n  \"platform_name\": \"cisco_ios\",\n  \"negation_default_when\": [],\n  \"negation_negate_with\": [],\n  \"ordering\": [],\n  \"idempotent_commands_avoid\": [],\n  \"idempotent_commands\": []\n}\n</code></pre> Field Description negation_default_when Default negation patterns negation_negate_with How to negate commands ordering Command ordering rules idempotent_commands_avoid Commands to avoid idempotent_commands Idempotent commands"},{"location":"api/platforms/#validate-configuration","title":"Validate Configuration","text":"<p>Validate configuration for a specific platform.</p> <p>Endpoint: <code>POST /api/v1/platforms/{platform}/validate</code></p>"},{"location":"api/platforms/#request","title":"Request","text":"<pre><code>{\n  \"config_text\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\"\n}\n</code></pre>"},{"location":"api/platforms/#response_2","title":"Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"is_valid\": true,\n  \"warnings\": [\n    \"No NTP server configured\"\n  ],\n  \"errors\": []\n}\n</code></pre>"},{"location":"api/platforms/#error-response","title":"Error Response","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"is_valid\": false,\n  \"warnings\": [],\n  \"errors\": [\n    \"Configuration parsing error: Invalid syntax on line 5\"\n  ]\n}\n</code></pre>"},{"location":"api/platforms/#supported-platforms","title":"Supported Platforms","text":""},{"location":"api/platforms/#cisco-ios","title":"Cisco IOS","text":"<p>Platform ID: <code>cisco_ios</code></p> <ul> <li>Standard Cisco IOS devices</li> <li>Hierarchical configuration structure</li> <li>Full negation support</li> </ul>"},{"location":"api/platforms/#cisco-nx-os","title":"Cisco NX-OS","text":"<p>Platform ID: <code>cisco_nxos</code></p> <ul> <li>Cisco Nexus switches</li> <li>Data center switching platform</li> <li>Enhanced features support</li> </ul>"},{"location":"api/platforms/#cisco-ios-xr","title":"Cisco IOS-XR","text":"<p>Platform ID: <code>cisco_iosxr</code></p> <ul> <li>Carrier-grade routers</li> <li>XML-based configuration</li> <li>Advanced routing features</li> </ul>"},{"location":"api/platforms/#juniper-junos","title":"Juniper Junos","text":"<p>Platform ID: <code>juniper_junos</code></p> <ul> <li>Juniper Networks devices</li> <li>Hierarchical configuration</li> <li>Commit-based changes</li> </ul>"},{"location":"api/platforms/#arista-eos","title":"Arista EOS","text":"<p>Platform ID: <code>arista_eos</code></p> <ul> <li>Arista Networks switches</li> <li>Cloud networking platform</li> <li>Modern API support</li> </ul>"},{"location":"api/platforms/#generic","title":"Generic","text":"<p>Platform ID: <code>generic</code></p> <ul> <li>Fallback for unsupported platforms</li> <li>Basic hierarchical parsing</li> <li>Limited feature support</li> </ul>"},{"location":"api/remediation/","title":"Remediation Workflows","text":"<p>Generate and manage configuration remediation with tag-based filtering.</p>"},{"location":"api/remediation/#generate-remediation","title":"Generate Remediation","text":"<p>Generate remediation and rollback configurations.</p> <p>Endpoint: <code>POST /api/v1/remediation/generate</code></p>"},{"location":"api/remediation/#request","title":"Request","text":"<pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"running_config\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\",\n  \"intended_config\": \"hostname router2\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.2 255.255.255.0\",\n  \"tag_rules\": [\n    {\n      \"match_rules\": [\"hostname\"],\n      \"tags\": [\"safe\", \"non-service-impacting\"]\n    }\n  ],\n  \"include_tags\": [\"safe\"],\n  \"exclude_tags\": [\"risky\"]\n}\n</code></pre> Field Type Required Description platform string Yes Platform type running_config string Yes Current configuration intended_config string Yes Desired configuration tag_rules array No Tag rules to apply include_tags array No Only include these tags exclude_tags array No Exclude these tags"},{"location":"api/remediation/#response","title":"Response","text":"<pre><code>{\n  \"remediation_id\": \"abc-123-def-456\",\n  \"platform\": \"cisco_ios\",\n  \"remediation_config\": \"no hostname router1\\nhostname router2\\ninterface GigabitEthernet0/0\\n no ip address 192.168.1.1 255.255.255.0\\n ip address 192.168.1.2 255.255.255.0\",\n  \"rollback_config\": \"no hostname router2\\nhostname router1\\ninterface GigabitEthernet0/0\\n no ip address 192.168.1.2 255.255.255.0\\n ip address 192.168.1.1 255.255.255.0\",\n  \"summary\": {\n    \"additions\": 4,\n    \"deletions\": 4,\n    \"modifications\": 0\n  },\n  \"tags\": {}\n}\n</code></pre>"},{"location":"api/remediation/#apply-tags","title":"Apply Tags","text":"<p>Apply tag rules to an existing remediation.</p> <p>Endpoint: <code>POST /api/v1/remediation/{remediation_id}/tags</code></p>"},{"location":"api/remediation/#request_1","title":"Request","text":"<pre><code>{\n  \"tag_rules\": [\n    {\n      \"match_rules\": [\"interface\"],\n      \"tags\": [\"network-change\", \"review-required\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"api/remediation/#response_1","title":"Response","text":"<pre><code>{\n  \"remediation_id\": \"abc-123-def-456\",\n  \"remediation_config\": \"...\",\n  \"tags\": {\n    \"0\": [\"network-change\", \"review-required\"]\n  }\n}\n</code></pre>"},{"location":"api/remediation/#filter-remediation","title":"Filter Remediation","text":"<p>Filter remediation by tags.</p> <p>Endpoint: <code>GET /api/v1/remediation/{remediation_id}/filter</code></p>"},{"location":"api/remediation/#query-parameters","title":"Query Parameters","text":"Parameter Type Description include_tags array Only include these tags exclude_tags array Exclude these tags"},{"location":"api/remediation/#example","title":"Example","text":"<pre><code>curl \"http://localhost:8000/api/v1/remediation/abc-123/filter?include_tags=safe&amp;exclude_tags=risky\"\n</code></pre>"},{"location":"api/remediation/#response_2","title":"Response","text":"<pre><code>{\n  \"remediation_id\": \"abc-123-def-456\",\n  \"filtered_config\": \"hostname router2\",\n  \"summary\": {\n    \"additions\": 1,\n    \"deletions\": 0,\n    \"modifications\": 0\n  }\n}\n</code></pre>"},{"location":"api/reports/","title":"Multi-Device Reports","text":"<p>Create and analyze configuration reports across multiple devices.</p>"},{"location":"api/reports/#create-report","title":"Create Report","text":"<p>Create a multi-device configuration report.</p> <p>Endpoint: <code>POST /api/v1/reports</code></p>"},{"location":"api/reports/#request","title":"Request","text":"<pre><code>{\n  \"remediations\": [\n    {\n      \"device_id\": \"router1\",\n      \"platform\": \"cisco_ios\",\n      \"running_config\": \"hostname router1\",\n      \"intended_config\": \"hostname router1-new\"\n    },\n    {\n      \"device_id\": \"router2\",\n      \"platform\": \"cisco_ios\",\n      \"running_config\": \"hostname router2\",\n      \"intended_config\": \"hostname router2-new\"\n    },\n    {\n      \"device_id\": \"switch1\",\n      \"platform\": \"cisco_nxos\",\n      \"running_config\": \"hostname switch1\",\n      \"intended_config\": \"hostname switch1-new\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/reports/#response","title":"Response","text":"<pre><code>{\n  \"report_id\": \"report-abc-123\",\n  \"total_devices\": 3\n}\n</code></pre>"},{"location":"api/reports/#get-report-summary","title":"Get Report Summary","text":"<p>Get aggregated statistics for a report.</p> <p>Endpoint: <code>GET /api/v1/reports/{report_id}/summary</code></p>"},{"location":"api/reports/#response_1","title":"Response","text":"<pre><code>{\n  \"total_devices\": 3,\n  \"devices_with_changes\": 3,\n  \"total_changes\": 6,\n  \"changes_by_tag\": {\n    \"safe\": 3,\n    \"hostname-change\": 3\n  }\n}\n</code></pre> Field Type Description total_devices integer Total number of devices devices_with_changes integer Devices with configuration changes total_changes integer Total configuration changes changes_by_tag object Count of changes by tag"},{"location":"api/reports/#get-report-changes","title":"Get Report Changes","text":"<p>Get detailed change analysis showing common changes across devices.</p> <p>Endpoint: <code>GET /api/v1/reports/{report_id}/changes</code></p>"},{"location":"api/reports/#query-parameters","title":"Query Parameters","text":"Parameter Type Description tag string Filter by specific tag min_devices integer Minimum devices with this change"},{"location":"api/reports/#example","title":"Example","text":"<pre><code># Get changes appearing on at least 2 devices\ncurl \"http://localhost:8000/api/v1/reports/report-123/changes?min_devices=2\"\n</code></pre>"},{"location":"api/reports/#response_2","title":"Response","text":"<pre><code>{\n  \"report_id\": \"report-abc-123\",\n  \"changes\": [\n    {\n      \"change_text\": \"no hostname router1\",\n      \"device_count\": 2,\n      \"device_ids\": [\"router1\", \"router2\"],\n      \"tags\": [\"hostname-change\"]\n    },\n    {\n      \"change_text\": \"hostname router1-new\",\n      \"device_count\": 1,\n      \"device_ids\": [\"router1\"],\n      \"tags\": [\"hostname-change\", \"safe\"]\n    }\n  ],\n  \"total_unique_changes\": 2\n}\n</code></pre>"},{"location":"api/reports/#export-report","title":"Export Report","text":"<p>Export report in different formats.</p> <p>Endpoint: <code>GET /api/v1/reports/{report_id}/export</code></p>"},{"location":"api/reports/#query-parameters_1","title":"Query Parameters","text":"Parameter Type Values Description format string json, csv, yaml Export format"},{"location":"api/reports/#examples","title":"Examples","text":"<p>Export as JSON:</p> <pre><code>curl \"http://localhost:8000/api/v1/reports/report-123/export?format=json\"\n</code></pre> <p>Export as CSV:</p> <pre><code>curl \"http://localhost:8000/api/v1/reports/report-123/export?format=csv\" &gt; report.csv\n</code></pre> <p>Export as YAML:</p> <pre><code>curl \"http://localhost:8000/api/v1/reports/report-123/export?format=yaml\" &gt; report.yaml\n</code></pre>"},{"location":"api/reports/#csv-format","title":"CSV Format","text":"<pre><code>Device ID,Platform,Has Changes,Change Count,Remediation Summary\nrouter1,cisco_ios,True,2,no hostname router1...\nrouter2,cisco_ios,True,2,no hostname router2...\nswitch1,cisco_nxos,True,2,no hostname switch1...\n</code></pre>"},{"location":"api/reports/#use-cases","title":"Use Cases","text":""},{"location":"api/reports/#fleet-wide-analysis","title":"Fleet-Wide Analysis","text":"<p>Identify common misconfigurations:</p> <pre><code>import requests\n\n# Create report for 100 devices\ndevices = [...]  # List of device configs\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/reports\",\n    json={\"remediations\": devices}\n)\n\nreport_id = response.json()[\"report_id\"]\n\n# Find changes appearing on 10+ devices\nchanges = requests.get(\n    f\"http://localhost:8000/api/v1/reports/{report_id}/changes\",\n    params={\"min_devices\": 10}\n).json()\n\nfor change in changes[\"changes\"]:\n    print(f\"{change['change_text']}: {change['device_count']} devices\")\n</code></pre>"},{"location":"api/reports/#change-impact-assessment","title":"Change Impact Assessment","text":"<p>Understand scope of a planned change:</p> <pre><code># Create report\nreport = requests.post(...).json()\n\n# Get summary\nsummary = requests.get(\n    f\"http://localhost:8000/api/v1/reports/{report['report_id']}/summary\"\n).json()\n\nprint(f\"Total devices affected: {summary['devices_with_changes']}\")\nprint(f\"Total changes: {summary['total_changes']}\")\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Workflows","text":"<p>Complex use cases and advanced patterns.</p>"},{"location":"examples/advanced/#tag-based-remediation-filtering","title":"Tag-Based Remediation Filtering","text":"<p>Generate remediation with selective deployment based on tags:</p> <pre><code>import requests\n\n# Define tag rules\ntag_rules = [\n    {\n        \"match_rules\": [\"hostname\"],\n        \"tags\": [\"safe\", \"non-service-impacting\"]\n    },\n    {\n        \"match_rules\": [\"interface.*shutdown\"],\n        \"tags\": [\"risky\", \"service-impacting\"]\n    },\n    {\n        \"match_rules\": [\"ntp server\"],\n        \"tags\": [\"safe\", \"infrastructure\"]\n    }\n]\n\n# Generate remediation with tags\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/remediation/generate\",\n    json={\n        \"platform\": \"cisco_ios\",\n        \"running_config\": open(\"current.cfg\").read(),\n        \"intended_config\": open(\"desired.cfg\").read(),\n        \"tag_rules\": tag_rules,\n        \"include_tags\": [\"safe\"],  # Only safe changes\n        \"exclude_tags\": [\"risky\"]  # Exclude risky changes\n    }\n)\n\nresult = response.json()\nprint(\"Safe remediation commands:\")\nprint(result[\"remediation_config\"])\n</code></pre>"},{"location":"examples/advanced/#fleet-wide-configuration-drift-analysis","title":"Fleet-Wide Configuration Drift Analysis","text":"<p>Identify common drift across your network:</p> <pre><code>import requests\nfrom collections import defaultdict\n\n# Load device configs from your inventory\ndevices = load_device_inventory()\n\n# Create report\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/reports\",\n    json={\n        \"remediations\": [\n            {\n                \"device_id\": device[\"name\"],\n                \"platform\": device[\"platform\"],\n                \"running_config\": device[\"running_config\"],\n                \"intended_config\": device[\"intended_config\"]\n            }\n            for device in devices\n        ]\n    }\n)\n\nreport_id = response.json()[\"report_id\"]\n\n# Find common changes appearing on many devices\nchanges = requests.get(\n    f\"http://localhost:8000/api/v1/reports/{report_id}/changes\",\n    params={\"min_devices\": 10}  # Changes on 10+ devices\n).json()\n\n# Group by change type\ndrift_analysis = defaultdict(list)\nfor change in changes[\"changes\"]:\n    change_type = categorize_change(change[\"change_text\"])\n    drift_analysis[change_type].append({\n        \"change\": change[\"change_text\"],\n        \"device_count\": change[\"device_count\"],\n        \"devices\": change[\"device_ids\"]\n    })\n\n# Report findings\nfor change_type, items in drift_analysis.items():\n    print(f\"\\n{change_type}:\")\n    for item in items:\n        print(f\"  {item['device_count']} devices: {item['change']}\")\n</code></pre>"},{"location":"examples/advanced/#incremental-deployment-pipeline","title":"Incremental Deployment Pipeline","text":"<p>Deploy changes incrementally with validation:</p> <pre><code>import requests\nimport time\n\nclass DeploymentPipeline:\n    def __init__(self, api_url):\n        self.api_url = api_url\n\n    def generate_remediation(self, device, running_config, intended_config):\n        \"\"\"Generate remediation for a device.\"\"\"\n        response = requests.post(\n            f\"{self.api_url}/api/v1/remediation/generate\",\n            json={\n                \"platform\": device[\"platform\"],\n                \"running_config\": running_config,\n                \"intended_config\": intended_config,\n                \"tag_rules\": [\n                    {\"match_rules\": [\"hostname\"], \"tags\": [\"stage1\"]},\n                    {\"match_rules\": [\"interface\"], \"tags\": [\"stage2\"]},\n                    {\"match_rules\": [\"routing\"], \"tags\": [\"stage3\"]}\n                ]\n            }\n        )\n        return response.json()\n\n    def deploy_stage(self, remediation_id, stage_tags):\n        \"\"\"Get remediation for a specific deployment stage.\"\"\"\n        response = requests.get(\n            f\"{self.api_url}/api/v1/remediation/{remediation_id}/filter\",\n            params={\"include_tags\": \",\".join(stage_tags)}\n        )\n        return response.json()\n\n    def execute(self, devices):\n        \"\"\"Execute multi-stage deployment.\"\"\"\n        stages = [\n            {\"name\": \"Stage 1: Non-impacting\", \"tags\": [\"stage1\"]},\n            {\"name\": \"Stage 2: Interface changes\", \"tags\": [\"stage2\"]},\n            {\"name\": \"Stage 3: Routing changes\", \"tags\": [\"stage3\"]}\n        ]\n\n        for device in devices:\n            print(f\"\\n=== Deploying to {device['name']} ===\")\n\n            # Generate full remediation\n            remediation = self.generate_remediation(\n                device,\n                device[\"running_config\"],\n                device[\"intended_config\"]\n            )\n\n            # Deploy in stages\n            for stage in stages:\n                print(f\"\\n{stage['name']}:\")\n\n                # Get stage-specific commands\n                stage_config = self.deploy_stage(\n                    remediation[\"remediation_id\"],\n                    stage[\"tags\"]\n                )\n\n                if not stage_config[\"filtered_config\"]:\n                    print(\"  No changes in this stage\")\n                    continue\n\n                # Show what will be deployed\n                print(f\"  Commands:\\n{stage_config['filtered_config']}\")\n\n                # Wait for confirmation\n                if not self.confirm_deployment():\n                    print(\"  Deployment cancelled\")\n                    break\n\n                # Deploy to device\n                self.apply_to_device(device, stage_config[\"filtered_config\"])\n\n                # Verify\n                if self.verify_deployment(device):\n                    print(\"  \u2713 Deployment successful\")\n                else:\n                    print(\"  \u2717 Deployment failed, rolling back\")\n                    self.rollback(device, remediation[\"rollback_config\"])\n                    break\n\n                # Wait before next stage\n                time.sleep(30)\n\n# Usage\npipeline = DeploymentPipeline(\"http://localhost:8000\")\npipeline.execute(devices)\n</code></pre>"},{"location":"examples/advanced/#configuration-compliance-checking","title":"Configuration Compliance Checking","text":"<p>Check compliance across devices:</p> <pre><code>import requests\n\nclass ComplianceChecker:\n    def __init__(self, api_url, compliance_config):\n        self.api_url = api_url\n        self.compliance_config = compliance_config\n\n    def check_device(self, device):\n        \"\"\"Check a single device for compliance.\"\"\"\n        response = requests.post(\n            f\"{self.api_url}/api/v1/remediation/generate\",\n            json={\n                \"platform\": device[\"platform\"],\n                \"running_config\": device[\"config\"],\n                \"intended_config\": self.compliance_config\n            }\n        )\n\n        result = response.json()\n        violations = []\n\n        if result[\"summary\"][\"additions\"] &gt; 0:\n            violations.append({\n                \"type\": \"missing_config\",\n                \"severity\": \"high\",\n                \"remediation\": result[\"remediation_config\"]\n            })\n\n        return {\n            \"device_id\": device[\"id\"],\n            \"compliant\": len(violations) == 0,\n            \"violations\": violations\n        }\n\n    def check_fleet(self, devices):\n        \"\"\"Check compliance for entire fleet.\"\"\"\n        results = []\n\n        # Create batch job\n        response = requests.post(\n            f\"{self.api_url}/api/v1/batch/remediation\",\n            json={\n                \"device_configs\": [\n                    {\n                        \"device_id\": d[\"id\"],\n                        \"platform\": d[\"platform\"],\n                        \"running_config\": d[\"config\"],\n                        \"intended_config\": self.compliance_config\n                    }\n                    for d in devices\n                ]\n            }\n        )\n\n        job_id = response.json()[\"job_id\"]\n\n        # Wait for completion\n        while True:\n            status = requests.get(\n                f\"{self.api_url}/api/v1/batch/jobs/{job_id}\"\n            ).json()\n\n            if status[\"status\"] == \"completed\":\n                break\n\n            time.sleep(1)\n\n        # Get results\n        job_results = requests.get(\n            f\"{self.api_url}/api/v1/batch/jobs/{job_id}/results\"\n        ).json()\n\n        # Analyze compliance\n        for result in job_results[\"results\"]:\n            compliant = not result.get(\"remediation\", \"\").strip()\n            results.append({\n                \"device_id\": result[\"device_id\"],\n                \"compliant\": compliant,\n                \"remediation\": result.get(\"remediation\", \"\")\n            })\n\n        return results\n\n# Usage\nchecker = ComplianceChecker(\n    \"http://localhost:8000\",\n    compliance_config=open(\"compliance_baseline.cfg\").read()\n)\n\nresults = checker.check_fleet(devices)\n\n# Generate compliance report\ncompliant = [r for r in results if r[\"compliant\"]]\nnon_compliant = [r for r in results if not r[\"compliant\"]]\n\nprint(f\"Compliance Rate: {len(compliant)}/{len(results)} ({len(compliant)/len(results)*100:.1f}%)\")\nprint(f\"\\nNon-compliant devices:\")\nfor device in non_compliant:\n    print(f\"  - {device['device_id']}\")\n</code></pre>"},{"location":"examples/advanced/#change-approval-workflow","title":"Change Approval Workflow","text":"<p>Implement approval workflow for changes:</p> <pre><code>import requests\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass ChangeStatus(Enum):\n    PENDING = \"pending\"\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    DEPLOYED = \"deployed\"\n\n@dataclass\nclass ChangeRequest:\n    device_id: str\n    remediation_id: str\n    remediation_config: str\n    rollback_config: str\n    status: ChangeStatus\n    approver: str = None\n\nclass ChangeManagement:\n    def __init__(self, api_url):\n        self.api_url = api_url\n        self.changes = {}\n\n    def submit_change(self, device, running_config, intended_config):\n        \"\"\"Submit a change for approval.\"\"\"\n        response = requests.post(\n            f\"{self.api_url}/api/v1/remediation/generate\",\n            json={\n                \"platform\": device[\"platform\"],\n                \"running_config\": running_config,\n                \"intended_config\": intended_config\n            }\n        )\n\n        result = response.json()\n        change_id = result[\"remediation_id\"]\n\n        self.changes[change_id] = ChangeRequest(\n            device_id=device[\"id\"],\n            remediation_id=change_id,\n            remediation_config=result[\"remediation_config\"],\n            rollback_config=result[\"rollback_config\"],\n            status=ChangeStatus.PENDING\n        )\n\n        return change_id\n\n    def approve_change(self, change_id, approver):\n        \"\"\"Approve a change.\"\"\"\n        if change_id not in self.changes:\n            raise ValueError(\"Change not found\")\n\n        self.changes[change_id].status = ChangeStatus.APPROVED\n        self.changes[change_id].approver = approver\n\n    def deploy_approved_changes(self):\n        \"\"\"Deploy all approved changes.\"\"\"\n        for change_id, change in self.changes.items():\n            if change.status == ChangeStatus.APPROVED:\n                print(f\"Deploying {change.device_id}...\")\n                # Deploy to device\n                # ...\n                change.status = ChangeStatus.DEPLOYED\n\n# Usage\ncm = ChangeManagement(\"http://localhost:8000\")\n\n# Submit changes\nchange_id = cm.submit_change(device, current_config, desired_config)\n\n# Approve\ncm.approve_change(change_id, \"john.doe@example.com\")\n\n# Deploy\ncm.deploy_approved_changes()\n</code></pre>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>Common use cases and examples for hier-config-api.</p>"},{"location":"examples/basic/#simple-configuration-comparison","title":"Simple Configuration Comparison","text":"<p>Compare two configurations to see what changed:</p> <pre><code>import requests\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/configs/compare\",\n    json={\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"\"\"\nhostname router1\ninterface GigabitEthernet0/0\n ip address 192.168.1.1 255.255.255.0\n no shutdown\n\"\"\",\n        \"intended_config\": \"\"\"\nhostname router2\ninterface GigabitEthernet0/0\n ip address 192.168.1.2 255.255.255.0\n description WAN Link\n no shutdown\n\"\"\"\n    }\n)\n\nresult = response.json()\nprint(result[\"unified_diff\"])\nprint(f\"Has changes: {result['has_changes']}\")\n</code></pre>"},{"location":"examples/basic/#generate-remediation-commands","title":"Generate Remediation Commands","text":"<p>Get commands to achieve desired state:</p> <pre><code>import requests\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/remediation/generate\",\n    json={\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"hostname router1\",\n        \"intended_config\": \"hostname router2\"\n    }\n)\n\nresult = response.json()\nprint(\"Remediation:\")\nprint(result[\"remediation_config\"])\nprint(\"\\nRollback:\")\nprint(result[\"rollback_config\"])\nprint(f\"\\nSummary: {result['summary']}\")\n</code></pre>"},{"location":"examples/basic/#parse-configuration","title":"Parse Configuration","text":"<p>Parse configuration into structured format:</p> <pre><code>import requests\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/configs/parse\",\n    json={\n        \"platform\": \"cisco_ios\",\n        \"config_text\": \"\"\"\nhostname router1\n!\ninterface GigabitEthernet0/0\n description WAN Link\n ip address 192.168.1.1 255.255.255.0\n no shutdown\n!\ninterface GigabitEthernet0/1\n description LAN Link\n ip address 10.0.0.1 255.255.255.0\n no shutdown\n\"\"\"\n    }\n)\n\nconfig = response.json()[\"structured_config\"]\nprint(f\"Root: {config['text']}\")\nfor child in config['children']:\n    print(f\"  - {child['text']}\")\n</code></pre>"},{"location":"examples/basic/#search-configuration","title":"Search Configuration","text":"<p>Find specific configuration lines:</p> <pre><code>import requests\n\n# Search for all interface configurations\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/configs/search\",\n    json={\n        \"platform\": \"cisco_ios\",\n        \"config_text\": \"...\",\n        \"match_rules\": {\n            \"startswith\": \"interface\"\n        }\n    }\n)\n\nmatches = response.json()[\"matches\"]\nfor match in matches:\n    print(match)\n</code></pre>"},{"location":"examples/basic/#multi-device-analysis","title":"Multi-Device Analysis","text":"<p>Analyze changes across multiple devices:</p> <pre><code>import requests\n\n# Create report for multiple devices\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/reports\",\n    json={\n        \"remediations\": [\n            {\n                \"device_id\": \"router1\",\n                \"platform\": \"cisco_ios\",\n                \"running_config\": \"hostname router1\",\n                \"intended_config\": \"hostname router1-new\"\n            },\n            {\n                \"device_id\": \"router2\",\n                \"platform\": \"cisco_ios\",\n                \"running_config\": \"hostname router2\",\n                \"intended_config\": \"hostname router2-new\"\n            },\n            {\n                \"device_id\": \"switch1\",\n                \"platform\": \"cisco_nxos\",\n                \"running_config\": \"hostname switch1\",\n                \"intended_config\": \"hostname switch1-new\"\n            }\n        ]\n    }\n)\n\nreport_id = response.json()[\"report_id\"]\n\n# Get summary\nsummary = requests.get(\n    f\"http://localhost:8000/api/v1/reports/{report_id}/summary\"\n).json()\n\nprint(f\"Total devices: {summary['total_devices']}\")\nprint(f\"Devices with changes: {summary['devices_with_changes']}\")\nprint(f\"Total changes: {summary['total_changes']}\")\n\n# Export to CSV\ncsv_data = requests.get(\n    f\"http://localhost:8000/api/v1/reports/{report_id}/export\",\n    params={\"format\": \"csv\"}\n).text\n\nwith open(\"report.csv\", \"w\") as f:\n    f.write(csv_data)\n</code></pre>"},{"location":"examples/basic/#batch-processing","title":"Batch Processing","text":"<p>Process multiple devices in parallel:</p> <pre><code>import requests\nimport time\n\n# Prepare device list\ndevices = []\nfor i in range(10):\n    devices.append({\n        \"device_id\": f\"router{i}\",\n        \"platform\": \"cisco_ios\",\n        \"running_config\": f\"hostname router{i}\",\n        \"intended_config\": f\"hostname router{i}-new\"\n    })\n\n# Submit batch job\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/batch/remediation\",\n    json={\"device_configs\": devices}\n)\n\njob_id = response.json()[\"job_id\"]\nprint(f\"Job ID: {job_id}\")\n\n# Monitor progress\nwhile True:\n    status = requests.get(\n        f\"http://localhost:8000/api/v1/batch/jobs/{job_id}\"\n    ).json()\n\n    print(f\"Progress: {status['progress']:.1f}%\")\n\n    if status['status'] in ['completed', 'failed']:\n        break\n\n    time.sleep(1)\n\n# Get results\nresults = requests.get(\n    f\"http://localhost:8000/api/v1/batch/jobs/{job_id}/results\"\n).json()\n\nfor result in results['results']:\n    if result['status'] == 'success':\n        print(f\"{result['device_id']}: Success\")\n    else:\n        print(f\"{result['device_id']}: Failed - {result['error']}\")\n</code></pre>"},{"location":"examples/basic/#platform-information","title":"Platform Information","text":"<p>Get supported platforms:</p> <pre><code>import requests\n\nplatforms = requests.get(\n    \"http://localhost:8000/api/v1/platforms\"\n).json()\n\nfor platform in platforms:\n    print(f\"{platform['display_name']} ({platform['platform_name']})\")\n</code></pre>"},{"location":"examples/basic/#validate-configuration","title":"Validate Configuration","text":"<p>Validate configuration syntax:</p> <pre><code>import requests\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/platforms/cisco_ios/validate\",\n    json={\n        \"config_text\": \"\"\"\nhostname router1\ninterface GigabitEthernet0/0\n ip address 192.168.1.1 255.255.255.0\n\"\"\"\n    }\n)\n\nresult = response.json()\nif result[\"is_valid\"]:\n    print(\"Configuration is valid\")\nelse:\n    print(\"Configuration has errors:\")\n    for error in result[\"errors\"]:\n        print(f\"  - {error}\")\n</code></pre>"},{"location":"examples/python-client/","title":"Python Client","text":"<p>Example Python client library for hier-config-api.</p>"},{"location":"examples/python-client/#simple-client-implementation","title":"Simple Client Implementation","text":"<pre><code>import requests\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass RemediationResult:\n    \"\"\"Remediation result container.\"\"\"\n    remediation_id: str\n    platform: str\n    remediation_config: str\n    rollback_config: str\n    summary: Dict[str, int]\n    tags: Dict[str, List[str]]\n\nclass HierConfigAPIClient:\n    \"\"\"Client for hier-config-api.\"\"\"\n\n    def __init__(self, base_url: str = \"http://localhost:8000\"):\n        \"\"\"Initialize client.\n\n        Args:\n            base_url: Base URL of the API server\n        \"\"\"\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = requests.Session()\n\n    def _post(self, endpoint: str, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Make POST request.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        response = self.session.post(url, json=data)\n        response.raise_for_status()\n        return response.json()\n\n    def _get(self, endpoint: str, params: Optional[Dict[str, Any]] = None) -&gt; Dict[str, Any]:\n        \"\"\"Make GET request.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        response = self.session.get(url, params=params)\n        response.raise_for_status()\n        return response.json()\n\n    def compare_configs(\n        self,\n        platform: str,\n        running_config: str,\n        intended_config: str\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Compare two configurations.\n\n        Args:\n            platform: Platform type\n            running_config: Current configuration\n            intended_config: Desired configuration\n\n        Returns:\n            Comparison result with diff\n        \"\"\"\n        return self._post(\"/api/v1/configs/compare\", {\n            \"platform\": platform,\n            \"running_config\": running_config,\n            \"intended_config\": intended_config\n        })\n\n    def generate_remediation(\n        self,\n        platform: str,\n        running_config: str,\n        intended_config: str,\n        tag_rules: Optional[List[Dict[str, Any]]] = None,\n        include_tags: Optional[List[str]] = None,\n        exclude_tags: Optional[List[str]] = None\n    ) -&gt; RemediationResult:\n        \"\"\"Generate remediation configuration.\n\n        Args:\n            platform: Platform type\n            running_config: Current configuration\n            intended_config: Desired configuration\n            tag_rules: Optional tag rules\n            include_tags: Tags to include\n            exclude_tags: Tags to exclude\n\n        Returns:\n            Remediation result\n        \"\"\"\n        data = {\n            \"platform\": platform,\n            \"running_config\": running_config,\n            \"intended_config\": intended_config\n        }\n\n        if tag_rules:\n            data[\"tag_rules\"] = tag_rules\n        if include_tags:\n            data[\"include_tags\"] = include_tags\n        if exclude_tags:\n            data[\"exclude_tags\"] = exclude_tags\n\n        result = self._post(\"/api/v1/remediation/generate\", data)\n\n        return RemediationResult(\n            remediation_id=result[\"remediation_id\"],\n            platform=result[\"platform\"],\n            remediation_config=result[\"remediation_config\"],\n            rollback_config=result[\"rollback_config\"],\n            summary=result[\"summary\"],\n            tags=result[\"tags\"]\n        )\n\n    def create_report(\n        self,\n        devices: List[Dict[str, str]]\n    ) -&gt; str:\n        \"\"\"Create multi-device report.\n\n        Args:\n            devices: List of device configs\n\n        Returns:\n            Report ID\n        \"\"\"\n        result = self._post(\"/api/v1/reports\", {\n            \"remediations\": devices\n        })\n        return result[\"report_id\"]\n\n    def get_report_summary(self, report_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get report summary.\n\n        Args:\n            report_id: Report identifier\n\n        Returns:\n            Report summary\n        \"\"\"\n        return self._get(f\"/api/v1/reports/{report_id}/summary\")\n\n    def get_report_changes(\n        self,\n        report_id: str,\n        tag: Optional[str] = None,\n        min_devices: int = 1\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get detailed changes from report.\n\n        Args:\n            report_id: Report identifier\n            tag: Filter by tag\n            min_devices: Minimum device count\n\n        Returns:\n            Change details\n        \"\"\"\n        params = {\"min_devices\": min_devices}\n        if tag:\n            params[\"tag\"] = tag\n\n        return self._get(f\"/api/v1/reports/{report_id}/changes\", params)\n\n    def export_report(\n        self,\n        report_id: str,\n        format: str = \"json\"\n    ) -&gt; str:\n        \"\"\"Export report in specified format.\n\n        Args:\n            report_id: Report identifier\n            format: Export format (json, csv, yaml)\n\n        Returns:\n            Report content\n        \"\"\"\n        url = f\"{self.base_url}/api/v1/reports/{report_id}/export\"\n        response = self.session.get(url, params={\"format\": format})\n        response.raise_for_status()\n        return response.text\n\n    def list_platforms(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"List supported platforms.\n\n        Returns:\n            List of platform information\n        \"\"\"\n        return self._get(\"/api/v1/platforms\")\n\n    def validate_config(\n        self,\n        platform: str,\n        config_text: str\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Validate configuration.\n\n        Args:\n            platform: Platform type\n            config_text: Configuration to validate\n\n        Returns:\n            Validation result\n        \"\"\"\n        return self._post(f\"/api/v1/platforms/{platform}/validate\", {\n            \"config_text\": config_text\n        })\n\n    def create_batch_job(\n        self,\n        devices: List[Dict[str, str]]\n    ) -&gt; str:\n        \"\"\"Create batch remediation job.\n\n        Args:\n            devices: List of device configs\n\n        Returns:\n            Job ID\n        \"\"\"\n        result = self._post(\"/api/v1/batch/remediation\", {\n            \"device_configs\": devices\n        })\n        return result[\"job_id\"]\n\n    def get_batch_status(self, job_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get batch job status.\n\n        Args:\n            job_id: Job identifier\n\n        Returns:\n            Job status\n        \"\"\"\n        return self._get(f\"/api/v1/batch/jobs/{job_id}\")\n\n    def get_batch_results(self, job_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get batch job results.\n\n        Args:\n            job_id: Job identifier\n\n        Returns:\n            Job results\n        \"\"\"\n        return self._get(f\"/api/v1/batch/jobs/{job_id}/results\")\n</code></pre>"},{"location":"examples/python-client/#usage-examples","title":"Usage Examples","text":""},{"location":"examples/python-client/#basic-usage","title":"Basic Usage","text":"<pre><code>from hier_config_client import HierConfigAPIClient\n\n# Initialize client\nclient = HierConfigAPIClient(\"http://localhost:8000\")\n\n# Compare configs\nresult = client.compare_configs(\n    platform=\"cisco_ios\",\n    running_config=\"hostname router1\",\n    intended_config=\"hostname router2\"\n)\n\nprint(result[\"unified_diff\"])\n</code></pre>"},{"location":"examples/python-client/#generate-remediation","title":"Generate Remediation","text":"<pre><code># Generate remediation\nremediation = client.generate_remediation(\n    platform=\"cisco_ios\",\n    running_config=open(\"current.cfg\").read(),\n    intended_config=open(\"desired.cfg\").read()\n)\n\nprint(\"Remediation:\")\nprint(remediation.remediation_config)\n\nprint(\"\\nRollback:\")\nprint(remediation.rollback_config)\n\nprint(f\"\\nSummary: {remediation.summary}\")\n</code></pre>"},{"location":"examples/python-client/#multi-device-report","title":"Multi-Device Report","text":"<pre><code># Create report\ndevices = [\n    {\n        \"device_id\": \"router1\",\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"...\",\n        \"intended_config\": \"...\"\n    },\n    {\n        \"device_id\": \"router2\",\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"...\",\n        \"intended_config\": \"...\"\n    }\n]\n\nreport_id = client.create_report(devices)\n\n# Get summary\nsummary = client.get_report_summary(report_id)\nprint(f\"Devices with changes: {summary['devices_with_changes']}\")\n\n# Export to CSV\ncsv_data = client.export_report(report_id, format=\"csv\")\nwith open(\"report.csv\", \"w\") as f:\n    f.write(csv_data)\n</code></pre>"},{"location":"examples/python-client/#batch-processing","title":"Batch Processing","text":"<pre><code>import time\n\n# Create batch job\njob_id = client.create_batch_job(devices)\nprint(f\"Job ID: {job_id}\")\n\n# Monitor progress\nwhile True:\n    status = client.get_batch_status(job_id)\n    print(f\"Progress: {status['progress']:.1f}%\")\n\n    if status['status'] in ['completed', 'failed']:\n        break\n\n    time.sleep(2)\n\n# Get results\nresults = client.get_batch_results(job_id)\nfor result in results['results']:\n    print(f\"{result['device_id']}: {result['status']}\")\n</code></pre>"},{"location":"examples/python-client/#context-manager","title":"Context Manager","text":"<pre><code>class HierConfigAPIClient:\n    # ... previous code ...\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.session.close()\n\n# Usage with context manager\nwith HierConfigAPIClient(\"http://localhost:8000\") as client:\n    result = client.compare_configs(...)\n</code></pre>"},{"location":"examples/python-client/#async-client","title":"Async Client","text":"<pre><code>import httpx\nfrom typing import List, Dict, Any\n\nclass AsyncHierConfigAPIClient:\n    \"\"\"Async client for hier-config-api.\"\"\"\n\n    def __init__(self, base_url: str = \"http://localhost:8000\"):\n        self.base_url = base_url.rstrip(\"/\")\n        self.client = httpx.AsyncClient()\n\n    async def compare_configs(\n        self,\n        platform: str,\n        running_config: str,\n        intended_config: str\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Compare configurations asynchronously.\"\"\"\n        url = f\"{self.base_url}/api/v1/configs/compare\"\n        response = await self.client.post(url, json={\n            \"platform\": platform,\n            \"running_config\": running_config,\n            \"intended_config\": intended_config\n        })\n        response.raise_for_status()\n        return response.json()\n\n    async def close(self):\n        \"\"\"Close client.\"\"\"\n        await self.client.aclose()\n\n# Usage\nimport asyncio\n\nasync def main():\n    client = AsyncHierConfigAPIClient()\n    try:\n        result = await client.compare_configs(...)\n        print(result)\n    finally:\n        await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>hier-config-api can be configured through environment variables and command-line options.</p>"},{"location":"getting-started/configuration/#server-configuration","title":"Server Configuration","text":""},{"location":"getting-started/configuration/#host-and-port","title":"Host and Port","text":"<p>By default, the server runs on <code>127.0.0.1:8000</code>. Configure this with uvicorn options:</p> <pre><code># Custom host and port\npoetry run uvicorn hier_config_api.main:app --host 0.0.0.0 --port 8080\n\n# Listen on all interfaces\npoetry run uvicorn hier_config_api.main:app --host 0.0.0.0\n</code></pre>"},{"location":"getting-started/configuration/#workers","title":"Workers","text":"<p>For production, use multiple workers:</p> <pre><code>poetry run uvicorn hier_config_api.main:app --workers 4\n</code></pre>"},{"location":"getting-started/configuration/#ssltls","title":"SSL/TLS","text":"<p>For HTTPS support:</p> <pre><code>poetry run uvicorn hier_config_api.main:app \\\n  --ssl-keyfile=/path/to/key.pem \\\n  --ssl-certfile=/path/to/cert.pem\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Currently, hier-config-api uses minimal configuration. Future versions will support:</p> <ul> <li><code>API_PREFIX</code> - Custom API path prefix</li> <li><code>LOG_LEVEL</code> - Logging verbosity</li> <li><code>CORS_ORIGINS</code> - Allowed CORS origins</li> </ul>"},{"location":"getting-started/configuration/#cors-configuration","title":"CORS Configuration","text":"<p>By default, CORS is enabled for all origins. In production, modify <code>hier_config_api/main.py</code>:</p> <pre><code>app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://your-frontend.com\"],  # Specific origins\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre>"},{"location":"getting-started/configuration/#logging","title":"Logging","text":"<p>Configure logging level with uvicorn:</p> <pre><code>poetry run uvicorn hier_config_api.main:app --log-level debug\n</code></pre> <p>Available levels:</p> <ul> <li><code>critical</code></li> <li><code>error</code></li> <li><code>warning</code></li> <li><code>info</code> (default)</li> <li><code>debug</code></li> <li><code>trace</code></li> </ul>"},{"location":"getting-started/configuration/#performance-tuning","title":"Performance Tuning","text":""},{"location":"getting-started/configuration/#worker-processes","title":"Worker Processes","text":"<p>Rule of thumb: <code>(2 * CPU cores) + 1</code></p> <pre><code># For a 4-core machine\npoetry run uvicorn hier_config_api.main:app --workers 9\n</code></pre>"},{"location":"getting-started/configuration/#worker-class","title":"Worker Class","text":"<p>For async workloads, use uvloop:</p> <pre><code>poetry run uvicorn hier_config_api.main:app --loop uvloop\n</code></pre>"},{"location":"getting-started/configuration/#timeout","title":"Timeout","text":"<p>Adjust timeout for long-running operations:</p> <pre><code>poetry run uvicorn hier_config_api.main:app --timeout-keep-alive 30\n</code></pre>"},{"location":"getting-started/configuration/#storage-configuration","title":"Storage Configuration","text":"<p>Currently, hier-config-api uses in-memory storage for reports and batch jobs. For production deployments with multiple workers, consider:</p> <ol> <li>Redis - For distributed caching</li> <li>PostgreSQL - For persistent storage</li> <li>File-based - For simple single-server deployments</li> </ol> <p>These options are planned for future releases.</p>"},{"location":"getting-started/configuration/#production-deployment","title":"Production Deployment","text":"<p>See the Deployment Guide for comprehensive production setup including:</p> <ul> <li>Nginx reverse proxy</li> <li>Systemd service</li> <li>Docker containers</li> <li>Kubernetes deployments</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install and set up hier-config-api.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Poetry for dependency management</li> <li>Git (for cloning the repository)</li> </ul>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":""},{"location":"getting-started/installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/netdevops/hier-config-api.git\ncd hier-config-api\n</code></pre>"},{"location":"getting-started/installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Using Poetry (recommended):</p> <pre><code>poetry install\n</code></pre> <p>This will:</p> <ul> <li>Create a virtual environment</li> <li>Install all dependencies from <code>pyproject.toml</code></li> <li>Install hier-config-api in development mode</li> </ul>"},{"location":"getting-started/installation/#3-verify-installation","title":"3. Verify Installation","text":"<p>Run the tests to ensure everything is working:</p> <pre><code>poetry run pytest\n</code></pre> <p>You should see output indicating all tests passed:</p> <pre><code>============================== 21 passed in 0.19s ==============================\n</code></pre>"},{"location":"getting-started/installation/#development-setup","title":"Development Setup","text":"<p>If you're planning to develop or contribute, install the development dependencies:</p> <pre><code>poetry install --with dev\n</code></pre> <p>This includes additional tools:</p> <ul> <li><code>pytest</code> - Testing framework</li> <li><code>ruff</code> - Linter and formatter</li> <li><code>mypy</code> - Type checker</li> <li><code>mkdocs</code> - Documentation builder</li> </ul>"},{"location":"getting-started/installation/#docker-setup-optional","title":"Docker Setup (Optional)","text":"<p>A Docker setup is planned for future releases. For now, use the Poetry installation method.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, proceed to the Quick Start guide to run your first API server.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get up and running with hier-config-api in minutes.</p>"},{"location":"getting-started/quickstart/#starting-the-server","title":"Starting the Server","text":""},{"location":"getting-started/quickstart/#development-mode","title":"Development Mode","text":"<p>Start the server with auto-reload enabled for development:</p> <pre><code>poetry run uvicorn hier_config_api.main:app --reload\n</code></pre> <p>You should see output like:</p> <pre><code>INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [12345] using StatReload\nINFO:     Started server process [12346]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre>"},{"location":"getting-started/quickstart/#production-mode","title":"Production Mode","text":"<p>For production deployments:</p> <pre><code>poetry run uvicorn hier_config_api.main:app --host 0.0.0.0 --port 8000 --workers 4\n</code></pre>"},{"location":"getting-started/quickstart/#accessing-the-api","title":"Accessing the API","text":""},{"location":"getting-started/quickstart/#interactive-documentation","title":"Interactive Documentation","text":"<p>Once the server is running, open your browser to:</p> <ul> <li>Swagger UI: http://localhost:8000/api/docs</li> <li>ReDoc: http://localhost:8000/api/redoc</li> </ul> <p>These provide interactive documentation where you can test endpoints directly.</p>"},{"location":"getting-started/quickstart/#api-endpoints","title":"API Endpoints","text":"<p>The API is available at: <code>http://localhost:8000/api/v1/</code></p>"},{"location":"getting-started/quickstart/#your-first-api-call","title":"Your First API Call","text":"<p>Let's compare two configurations to see what changes are needed.</p>"},{"location":"getting-started/quickstart/#using-curl","title":"Using curl","text":"<pre><code>curl -X POST http://localhost:8000/api/v1/configs/compare \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platform\": \"cisco_ios\",\n    \"running_config\": \"hostname router1\",\n    \"intended_config\": \"hostname router2\"\n  }'\n</code></pre> <p>Response:</p> <pre><code>{\n  \"platform\": \"cisco_ios\",\n  \"unified_diff\": \"--- running_config\\n+++ intended_config\\n+ no hostname router1\\n+ hostname router2\\n- no hostname router2\\n- hostname router1\",\n  \"has_changes\": true\n}\n</code></pre>"},{"location":"getting-started/quickstart/#using-python","title":"Using Python","text":"<pre><code>import requests\n\nresponse = requests.post(\n    \"http://localhost:8000/api/v1/configs/compare\",\n    json={\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"hostname router1\",\n        \"intended_config\": \"hostname router2\"\n    }\n)\n\nprint(response.json())\n</code></pre>"},{"location":"getting-started/quickstart/#generate-remediation","title":"Generate Remediation","text":"<p>Now let's generate remediation commands:</p> <pre><code>curl -X POST http://localhost:8000/api/v1/remediation/generate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"platform\": \"cisco_ios\",\n    \"running_config\": \"hostname router1\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.1 255.255.255.0\",\n    \"intended_config\": \"hostname router2\\ninterface GigabitEthernet0/0\\n ip address 192.168.1.2 255.255.255.0\"\n  }'\n</code></pre> <p>Response:</p> <pre><code>{\n  \"remediation_id\": \"abc-123-def-456\",\n  \"platform\": \"cisco_ios\",\n  \"remediation_config\": \"no hostname router1\\nhostname router2\\ninterface GigabitEthernet0/0\\n no ip address 192.168.1.1 255.255.255.0\\n ip address 192.168.1.2 255.255.255.0\",\n  \"rollback_config\": \"no hostname router2\\nhostname router1\\ninterface GigabitEthernet0/0\\n no ip address 192.168.1.2 255.255.255.0\\n ip address 192.168.1.1 255.255.255.0\",\n  \"summary\": {\n    \"additions\": 4,\n    \"deletions\": 4,\n    \"modifications\": 0\n  },\n  \"tags\": {}\n}\n</code></pre>"},{"location":"getting-started/quickstart/#multi-device-report","title":"Multi-Device Report","text":"<p>Create a report for multiple devices:</p> <pre><code>curl -X POST http://localhost:8000/api/v1/reports \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"remediations\": [\n      {\n        \"device_id\": \"router1\",\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"hostname router1\",\n        \"intended_config\": \"hostname router1-new\"\n      },\n      {\n        \"device_id\": \"router2\",\n        \"platform\": \"cisco_ios\",\n        \"running_config\": \"hostname router2\",\n        \"intended_config\": \"hostname router2-new\"\n      }\n    ]\n  }'\n</code></pre> <p>Response:</p> <pre><code>{\n  \"report_id\": \"report-123\",\n  \"total_devices\": 2\n}\n</code></pre> <p>Get the report summary:</p> <pre><code>curl http://localhost:8000/api/v1/reports/report-123/summary\n</code></pre>"},{"location":"getting-started/quickstart/#health-check","title":"Health Check","text":"<p>Verify the API is running:</p> <pre><code>curl http://localhost:8000/health\n</code></pre> <p>Response:</p> <pre><code>{\n  \"status\": \"healthy\"\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed endpoint documentation</li> <li>Check out Examples for more use cases</li> <li>Learn about Configuration options</li> </ul>"},{"location":"guides/contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to hier-config-api! This document provides guidelines for contributions.</p>"},{"location":"guides/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and professional in all interactions.</p>"},{"location":"guides/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"guides/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Open an issue on GitHub Issues with:</p> <ul> <li>Clear title and description</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Environment details (Python version, OS, etc.)</li> <li>Code samples or logs if applicable</li> </ul>"},{"location":"guides/contributing/#suggesting-features","title":"Suggesting Features","text":"<p>Open an issue with:</p> <ul> <li>Clear description of the feature</li> <li>Use cases and benefits</li> <li>Potential implementation approach</li> <li>Examples of similar features</li> </ul>"},{"location":"guides/contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Make your changes following our guidelines</li> <li>Add tests for new functionality</li> <li>Ensure all tests pass</li> <li>Run linters and formatters</li> <li>Commit with clear messages</li> <li>Push to your fork</li> <li>Open a Pull Request</li> </ol>"},{"location":"guides/contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"guides/contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints</li> <li>Write docstrings (Google style)</li> <li>Keep functions focused and small</li> <li>Use meaningful variable names</li> </ul>"},{"location":"guides/contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for all new code</li> <li>Maintain &gt;80% coverage</li> <li>Test both success and error cases</li> <li>Use fixtures for common test data</li> </ul>"},{"location":"guides/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation</li> <li>Add docstrings to new functions</li> <li>Include code examples where helpful</li> <li>Update changelog</li> </ul>"},{"location":"guides/contributing/#commit-messages","title":"Commit Messages","text":"<p>Use conventional commits format:</p> <pre><code>type(scope): subject\n\nbody (optional)\n\nfooter (optional)\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation - <code>test</code>: Tests - <code>refactor</code>: Code refactoring - <code>style</code>: Formatting - <code>chore</code>: Maintenance</p> <p>Examples: <pre><code>feat(api): add configuration validation endpoint\nfix(parser): handle empty configuration files\ndocs(api): update remediation examples\n</code></pre></p>"},{"location":"guides/contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated checks must pass (CI/CD)</li> <li>At least one maintainer review required</li> <li>Address review comments</li> <li>Squash commits if requested</li> <li>Maintainer merges when ready</li> </ol>"},{"location":"guides/contributing/#release-process","title":"Release Process","text":"<p>Releases follow semantic versioning (MAJOR.MINOR.PATCH):</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes</li> </ul>"},{"location":"guides/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Open a Discussion for questions</li> <li>Check existing Issues</li> <li>Review the Development Guide</li> </ul>"},{"location":"guides/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as the project.</p>"},{"location":"guides/deployment/","title":"Deployment Guide","text":"<p>Production deployment strategies for hier-config-api.</p>"},{"location":"guides/deployment/#systemd-service","title":"Systemd Service","text":""},{"location":"guides/deployment/#1-create-service-file","title":"1. Create Service File","text":"<p>Create <code>/etc/systemd/system/hier-config-api.service</code>:</p> <pre><code>[Unit]\nDescription=hier-config-api\nAfter=network.target\n\n[Service]\nType=simple\nUser=api\nGroup=api\nWorkingDirectory=/opt/hier-config-api\nEnvironment=\"PATH=/opt/hier-config-api/.venv/bin\"\nExecStart=/opt/hier-config-api/.venv/bin/uvicorn hier_config_api.main:app --host 0.0.0.0 --port 8000 --workers 4\nRestart=always\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"guides/deployment/#2-install-and-start","title":"2. Install and Start","text":"<pre><code>sudo systemctl daemon-reload\nsudo systemctl enable hier-config-api\nsudo systemctl start hier-config-api\nsudo systemctl status hier-config-api\n</code></pre>"},{"location":"guides/deployment/#nginx-reverse-proxy","title":"Nginx Reverse Proxy","text":""},{"location":"guides/deployment/#configuration","title":"Configuration","text":"<p>Create <code>/etc/nginx/sites-available/hier-config-api</code>:</p> <pre><code>upstream hier_config_api {\n    server 127.0.0.1:8000;\n}\n\nserver {\n    listen 80;\n    server_name api.example.com;\n\n    location / {\n        proxy_pass http://hier_config_api;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Timeouts for long-running operations\n        proxy_connect_timeout 300s;\n        proxy_send_timeout 300s;\n        proxy_read_timeout 300s;\n    }\n}\n</code></pre>"},{"location":"guides/deployment/#enable-https-with-lets-encrypt","title":"Enable HTTPS with Let's Encrypt","text":"<pre><code>sudo certbot --nginx -d api.example.com\n</code></pre>"},{"location":"guides/deployment/#docker-deployment","title":"Docker Deployment","text":""},{"location":"guides/deployment/#dockerfile","title":"Dockerfile","text":"<p>Create <code>Dockerfile</code>:</p> <pre><code>FROM python:3.11-slim\n\nWORKDIR /app\n\n# Install Poetry\nRUN pip install poetry==2.3.1\n\n# Copy dependency files\nCOPY pyproject.toml poetry.lock ./\n\n# Install dependencies\nRUN poetry config virtualenvs.create false \\\n    &amp;&amp; poetry install --no-interaction --no-ansi --no-root --only main\n\n# Copy application\nCOPY hier_config_api ./hier_config_api\n\n# Expose port\nEXPOSE 8000\n\n# Run application\nCMD [\"uvicorn\", \"hier_config_api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"guides/deployment/#build-and-run","title":"Build and Run","text":"<pre><code># Build image\ndocker build -t hier-config-api:latest .\n\n# Run container\ndocker run -d \\\n  --name hier-config-api \\\n  -p 8000:8000 \\\n  hier-config-api:latest\n</code></pre>"},{"location":"guides/deployment/#docker-compose","title":"Docker Compose","text":"<p>Create <code>docker-compose.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    restart: always\n    environment:\n      - LOG_LEVEL=info\n    command: uvicorn hier_config_api.main:app --host 0.0.0.0 --port 8000 --workers 4\n</code></pre> <p>Run:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"guides/deployment/#kubernetes-deployment","title":"Kubernetes Deployment","text":""},{"location":"guides/deployment/#deployment","title":"Deployment","text":"<p>Create <code>k8s/deployment.yaml</code>:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: hier-config-api\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: hier-config-api\n  template:\n    metadata:\n      labels:\n        app: hier-config-api\n    spec:\n      containers:\n      - name: api\n        image: hier-config-api:latest\n        ports:\n        - containerPort: 8000\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 10\n          periodSeconds: 30\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 10\n</code></pre>"},{"location":"guides/deployment/#service","title":"Service","text":"<p>Create <code>k8s/service.yaml</code>:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: hier-config-api\nspec:\n  selector:\n    app: hier-config-api\n  ports:\n  - port: 80\n    targetPort: 8000\n  type: LoadBalancer\n</code></pre>"},{"location":"guides/deployment/#deploy","title":"Deploy","text":"<pre><code>kubectl apply -f k8s/deployment.yaml\nkubectl apply -f k8s/service.yaml\n</code></pre>"},{"location":"guides/deployment/#production-checklist","title":"Production Checklist","text":""},{"location":"guides/deployment/#security","title":"Security","text":"<ul> <li>[ ] Enable HTTPS/TLS</li> <li>[ ] Implement authentication (API keys, OAuth)</li> <li>[ ] Configure CORS properly</li> <li>[ ] Set up rate limiting</li> <li>[ ] Use security headers</li> <li>[ ] Keep dependencies updated</li> </ul>"},{"location":"guides/deployment/#performance","title":"Performance","text":"<ul> <li>[ ] Configure appropriate worker count</li> <li>[ ] Enable caching where applicable</li> <li>[ ] Monitor resource usage</li> <li>[ ] Set up auto-scaling</li> <li>[ ] Configure timeouts</li> </ul>"},{"location":"guides/deployment/#monitoring","title":"Monitoring","text":"<ul> <li>[ ] Set up logging (structured logs)</li> <li>[ ] Configure metrics collection</li> <li>[ ] Set up health checks</li> <li>[ ] Configure alerting</li> <li>[ ] Monitor error rates</li> </ul>"},{"location":"guides/deployment/#reliability","title":"Reliability","text":"<ul> <li>[ ] Implement graceful shutdown</li> <li>[ ] Configure restart policies</li> <li>[ ] Set up backups (if using persistent storage)</li> <li>[ ] Test disaster recovery</li> <li>[ ] Document runbook procedures</li> </ul>"},{"location":"guides/deployment/#environment-variables","title":"Environment Variables","text":"<p>Future versions will support configuration via environment variables:</p> <pre><code>export API_PREFIX=/api/v1\nexport LOG_LEVEL=info\nexport CORS_ORIGINS=https://app.example.com\nexport MAX_WORKERS=4\n</code></pre>"},{"location":"guides/deployment/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"guides/deployment/#structured-logging","title":"Structured Logging","text":"<p>Configure JSON logging for better parsing:</p> <pre><code>import logging\nimport json\n\nlogging.basicConfig(\n    format='%(message)s',\n    level=logging.INFO\n)\n</code></pre>"},{"location":"guides/deployment/#prometheus-metrics","title":"Prometheus Metrics","text":"<p>Add prometheus-fastapi-instrumentator:</p> <pre><code>poetry add prometheus-fastapi-instrumentator\n</code></pre>"},{"location":"guides/deployment/#health-checks","title":"Health Checks","text":"<p>The <code>/health</code> endpoint provides basic health status. Extend it for deeper checks:</p> <pre><code>@app.get(\"/health\")\nasync def health():\n    return {\n        \"status\": \"healthy\",\n        \"version\": \"0.1.0\",\n        \"uptime\": get_uptime()\n    }\n</code></pre>"},{"location":"guides/development/","title":"Development Guide","text":"<p>Guide for setting up a development environment and contributing to hier-config-api.</p>"},{"location":"guides/development/#development-setup","title":"Development Setup","text":""},{"location":"guides/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Poetry 2.0+</li> <li>Git</li> </ul>"},{"location":"guides/development/#clone-and-install","title":"Clone and Install","text":"<pre><code># Clone repository\ngit clone https://github.com/netdevops/hier-config-api.git\ncd hier-config-api\n\n# Install all dependencies including dev tools\npoetry install\n\n# Activate virtual environment\npoetry shell\n</code></pre>"},{"location":"guides/development/#project-structure","title":"Project Structure","text":"<pre><code>hier-config-api/\n\u251c\u2500\u2500 hier_config_api/          # Main application code\n\u2502   \u251c\u2500\u2500 models/               # Pydantic models\n\u2502   \u251c\u2500\u2500 routers/              # API route handlers\n\u2502   \u251c\u2500\u2500 services/             # Business logic\n\u2502   \u251c\u2500\u2500 utils/                # Utilities\n\u2502   \u2514\u2500\u2500 main.py               # FastAPI application\n\u251c\u2500\u2500 tests/                    # Test suite\n\u2502   \u251c\u2500\u2500 conftest.py           # Pytest fixtures\n\u2502   \u251c\u2500\u2500 test_configs.py       # Config endpoint tests\n\u2502   \u251c\u2500\u2500 test_remediation.py   # Remediation tests\n\u2502   \u251c\u2500\u2500 test_reports.py       # Report tests\n\u2502   \u2514\u2500\u2500 test_platforms.py     # Platform tests\n\u251c\u2500\u2500 docs/                     # Documentation\n\u251c\u2500\u2500 .github/workflows/        # CI/CD workflows\n\u251c\u2500\u2500 pyproject.toml            # Project configuration\n\u2514\u2500\u2500 mkdocs.yml                # Documentation config\n</code></pre>"},{"location":"guides/development/#running-tests","title":"Running Tests","text":""},{"location":"guides/development/#all-tests","title":"All Tests","text":"<pre><code>poetry run pytest\n</code></pre>"},{"location":"guides/development/#with-coverage","title":"With Coverage","text":"<pre><code>poetry run pytest --cov=hier_config_api --cov-report=html\n</code></pre> <p>View coverage report at <code>htmlcov/index.html</code>.</p>"},{"location":"guides/development/#specific-test-file","title":"Specific Test File","text":"<pre><code>poetry run pytest tests/test_configs.py -v\n</code></pre>"},{"location":"guides/development/#single-test","title":"Single Test","text":"<pre><code>poetry run pytest tests/test_configs.py::test_parse_config -v\n</code></pre>"},{"location":"guides/development/#code-quality","title":"Code Quality","text":""},{"location":"guides/development/#linting","title":"Linting","text":"<p>Run ruff linter:</p> <pre><code>poetry run ruff check .\n</code></pre> <p>Auto-fix issues:</p> <pre><code>poetry run ruff check . --fix\n</code></pre>"},{"location":"guides/development/#formatting","title":"Formatting","text":"<p>Check formatting:</p> <pre><code>poetry run ruff format --check .\n</code></pre> <p>Format code:</p> <pre><code>poetry run ruff format .\n</code></pre>"},{"location":"guides/development/#type-checking","title":"Type Checking","text":"<p>Run mypy:</p> <pre><code>poetry run mypy hier_config_api\n</code></pre>"},{"location":"guides/development/#run-all-checks","title":"Run All Checks","text":"<pre><code>poetry run ruff check . &amp;&amp; \\\npoetry run ruff format --check . &amp;&amp; \\\npoetry run mypy hier_config_api &amp;&amp; \\\npoetry run pytest\n</code></pre>"},{"location":"guides/development/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/development/#1-create-feature-branch","title":"1. Create Feature Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n</code></pre>"},{"location":"guides/development/#2-make-changes","title":"2. Make Changes","text":"<p>Edit code following the project conventions:</p> <ul> <li>Use type hints for all functions</li> <li>Write docstrings for public APIs</li> <li>Follow existing code structure</li> <li>Add tests for new features</li> </ul>"},{"location":"guides/development/#3-run-tests","title":"3. Run Tests","text":"<pre><code>poetry run pytest\n</code></pre>"},{"location":"guides/development/#4-format-and-lint","title":"4. Format and Lint","text":"<pre><code>poetry run ruff format .\npoetry run ruff check .\npoetry run mypy hier_config_api\n</code></pre>"},{"location":"guides/development/#5-commit-changes","title":"5. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"Add new feature\"\n</code></pre> <p>Follow conventional commit format:</p> <ul> <li><code>feat: Add new endpoint</code></li> <li><code>fix: Resolve bug in parser</code></li> <li><code>docs: Update API documentation</code></li> <li><code>test: Add tests for reports</code></li> <li><code>refactor: Improve service layer</code></li> </ul>"},{"location":"guides/development/#6-push-and-create-pr","title":"6. Push and Create PR","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"guides/development/#adding-new-endpoints","title":"Adding New Endpoints","text":""},{"location":"guides/development/#1-define-pydantic-models","title":"1. Define Pydantic Models","text":"<p>Create request/response models in <code>hier_config_api/models/</code>:</p> <pre><code># models/myfeature.py\nfrom pydantic import BaseModel, Field\n\nclass MyFeatureRequest(BaseModel):\n    \"\"\"Request model for my feature.\"\"\"\n    param1: str = Field(..., description=\"Parameter 1\")\n    param2: int = Field(..., description=\"Parameter 2\")\n\nclass MyFeatureResponse(BaseModel):\n    \"\"\"Response model for my feature.\"\"\"\n    result: str = Field(..., description=\"Result value\")\n</code></pre>"},{"location":"guides/development/#2-implement-service-logic","title":"2. Implement Service Logic","text":"<p>Add business logic in <code>hier_config_api/services/</code>:</p> <pre><code># services/myfeature_service.py\nclass MyFeatureService:\n    \"\"\"Service for my feature.\"\"\"\n\n    @staticmethod\n    def process(param1: str, param2: int) -&gt; str:\n        \"\"\"Process the feature request.\"\"\"\n        # Implementation here\n        return f\"Processed: {param1} with {param2}\"\n</code></pre>"},{"location":"guides/development/#3-create-router","title":"3. Create Router","text":"<p>Add endpoints in <code>hier_config_api/routers/</code>:</p> <pre><code># routers/myfeature.py\nfrom fastapi import APIRouter, HTTPException\n\nfrom hier_config_api.models.myfeature import MyFeatureRequest, MyFeatureResponse\nfrom hier_config_api.services.myfeature_service import MyFeatureService\n\nrouter = APIRouter(prefix=\"/api/v1/myfeature\", tags=[\"myfeature\"])\n\n@router.post(\"\", response_model=MyFeatureResponse)\nasync def process_feature(request: MyFeatureRequest) -&gt; MyFeatureResponse:\n    \"\"\"Process my feature.\"\"\"\n    try:\n        result = MyFeatureService.process(request.param1, request.param2)\n        return MyFeatureResponse(result=result)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e)) from e\n</code></pre>"},{"location":"guides/development/#4-register-router","title":"4. Register Router","text":"<p>Add router to <code>hier_config_api/main.py</code>:</p> <pre><code>from hier_config_api.routers import myfeature\n\napp.include_router(myfeature.router)\n</code></pre>"},{"location":"guides/development/#5-write-tests","title":"5. Write Tests","text":"<p>Create tests in <code>tests/test_myfeature.py</code>:</p> <pre><code>def test_process_feature(client):\n    \"\"\"Test my feature endpoint.\"\"\"\n    response = client.post(\n        \"/api/v1/myfeature\",\n        json={\"param1\": \"test\", \"param2\": 42}\n    )\n    assert response.status_code == 200\n    assert \"result\" in response.json()\n</code></pre>"},{"location":"guides/development/#debugging","title":"Debugging","text":""},{"location":"guides/development/#vs-code","title":"VS Code","text":"<p>Create <code>.vscode/launch.json</code>:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"FastAPI\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"uvicorn\",\n      \"args\": [\n        \"hier_config_api.main:app\",\n        \"--reload\"\n      ],\n      \"jinja\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/development/#pycharm","title":"PyCharm","text":"<ol> <li>Edit Configurations \u2192 Add Python</li> <li>Script path: <code>uvicorn</code></li> <li>Parameters: <code>hier_config_api.main:app --reload</code></li> <li>Environment variables: <code>PYTHONUNBUFFERED=1</code></li> </ol>"},{"location":"guides/development/#documentation","title":"Documentation","text":"<p>Build documentation locally:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>View at http://localhost:8000</p> <p>Build static site:</p> <pre><code>poetry run mkdocs build\n</code></pre>"},{"location":"guides/development/#continuous-integration","title":"Continuous Integration","text":"<p>The project uses GitHub Actions for CI/CD. On push or PR:</p> <ol> <li>Lint Job: Runs ruff and mypy</li> <li>Test Job: Runs pytest on Python 3.10, 3.11, 3.12</li> </ol> <p>View workflow in <code>.github/workflows/ci.yml</code>.</p>"},{"location":"reference/","title":"hier_config_api","text":""},{"location":"reference/#hier_config_api","title":"<code>hier_config_api</code>","text":"<p>Hier-Config API - REST API for hier_config network configuration management.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>hier_config_api<ul> <li>main</li> <li>models<ul> <li>config</li> <li>platform</li> <li>remediation</li> <li>report</li> </ul> </li> <li>routers<ul> <li>batch</li> <li>configs</li> <li>platforms</li> <li>remediation</li> <li>reports</li> </ul> </li> <li>services<ul> <li>config_service</li> <li>platform_service</li> <li>remediation_service</li> <li>report_service</li> </ul> </li> <li>utils<ul> <li>storage</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/main/","title":"main","text":""},{"location":"reference/main/#hier_config_api.main","title":"<code>main</code>","text":"<p>Main FastAPI application for hier-config-api.</p>"},{"location":"reference/main/#hier_config_api.main.root","title":"<code>root()</code>  <code>async</code>","text":"<p>Root endpoint.</p> Source code in <code>hier_config_api/main.py</code> <pre><code>@app.get(\"/\")\nasync def root() -&gt; dict[str, str]:\n    \"\"\"Root endpoint.\"\"\"\n    return {\n        \"message\": \"Hier-Config API\",\n        \"version\": \"0.1.0\",\n        \"docs\": \"/api/docs\",\n    }\n</code></pre>"},{"location":"reference/main/#hier_config_api.main.health","title":"<code>health()</code>  <code>async</code>","text":"<p>Health check endpoint.</p> Source code in <code>hier_config_api/main.py</code> <pre><code>@app.get(\"/health\")\nasync def health() -&gt; dict[str, str]:\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"reference/models/","title":"models","text":""},{"location":"reference/models/#hier_config_api.models","title":"<code>models</code>","text":""},{"location":"reference/models/config/","title":"config","text":""},{"location":"reference/models/config/#hier_config_api.models.config","title":"<code>config</code>","text":"<p>Pydantic models for configuration operations.</p>"},{"location":"reference/models/config/#hier_config_api.models.config.ParseConfigRequest","title":"<code>ParseConfigRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for parsing configuration.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class ParseConfigRequest(BaseModel):\n    \"\"\"Request model for parsing configuration.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    config_text: str = Field(..., description=\"Raw configuration text to parse\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.ParseConfigResponse","title":"<code>ParseConfigResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for parsed configuration.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class ParseConfigResponse(BaseModel):\n    \"\"\"Response model for parsed configuration.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type\")\n    structured_config: dict[str, Any] = Field(..., description=\"Structured configuration tree\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.CompareConfigRequest","title":"<code>CompareConfigRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for comparing configurations.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class CompareConfigRequest(BaseModel):\n    \"\"\"Request model for comparing configurations.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    running_config: str = Field(..., description=\"Current running configuration\")\n    intended_config: str = Field(..., description=\"Desired configuration state\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.CompareConfigResponse","title":"<code>CompareConfigResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for configuration comparison.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class CompareConfigResponse(BaseModel):\n    \"\"\"Response model for configuration comparison.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type\")\n    unified_diff: str = Field(..., description=\"Unified diff showing differences\")\n    has_changes: bool = Field(..., description=\"Whether there are any differences\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.PredictConfigRequest","title":"<code>PredictConfigRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for predicting future configuration state.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class PredictConfigRequest(BaseModel):\n    \"\"\"Request model for predicting future configuration state.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    current_config: str = Field(..., description=\"Current configuration state\")\n    commands_to_apply: str = Field(..., description=\"Commands to apply to current config\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.PredictConfigResponse","title":"<code>PredictConfigResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for predicted configuration.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class PredictConfigResponse(BaseModel):\n    \"\"\"Response model for predicted configuration.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type\")\n    predicted_config: str = Field(\n        ..., description=\"Predicted configuration after applying commands\"\n    )\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.MergeConfigRequest","title":"<code>MergeConfigRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for merging multiple configurations.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class MergeConfigRequest(BaseModel):\n    \"\"\"Request model for merging multiple configurations.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    configs: list[str] = Field(..., description=\"List of configuration texts to merge\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.MergeConfigResponse","title":"<code>MergeConfigResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for merged configuration.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class MergeConfigResponse(BaseModel):\n    \"\"\"Response model for merged configuration.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type\")\n    merged_config: str = Field(..., description=\"Merged configuration result\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.MatchRule","title":"<code>MatchRule</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Rule for matching configuration lines.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class MatchRule(BaseModel):\n    \"\"\"Rule for matching configuration lines.\"\"\"\n\n    equals: str | None = Field(None, description=\"Exact match string\")\n    contains: str | None = Field(None, description=\"Substring to match\")\n    startswith: str | None = Field(None, description=\"Prefix to match\")\n    regex: str | None = Field(None, description=\"Regular expression pattern\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.SearchConfigRequest","title":"<code>SearchConfigRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for searching configuration.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class SearchConfigRequest(BaseModel):\n    \"\"\"Request model for searching configuration.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    config_text: str = Field(..., description=\"Configuration text to search\")\n    match_rules: MatchRule = Field(..., description=\"Rules for matching configuration sections\")\n</code></pre>"},{"location":"reference/models/config/#hier_config_api.models.config.SearchConfigResponse","title":"<code>SearchConfigResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for configuration search.</p> Source code in <code>hier_config_api/models/config.py</code> <pre><code>class SearchConfigResponse(BaseModel):\n    \"\"\"Response model for configuration search.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type\")\n    matches: list[str] = Field(..., description=\"Matching configuration sections\")\n    match_count: int = Field(..., description=\"Number of matches found\")\n</code></pre>"},{"location":"reference/models/platform/","title":"platform","text":""},{"location":"reference/models/platform/#hier_config_api.models.platform","title":"<code>platform</code>","text":"<p>Pydantic models for platform information.</p>"},{"location":"reference/models/platform/#hier_config_api.models.platform.PlatformInfo","title":"<code>PlatformInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a supported platform.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class PlatformInfo(BaseModel):\n    \"\"\"Information about a supported platform.\"\"\"\n\n    platform_name: str = Field(..., description=\"Platform identifier\")\n    display_name: str = Field(..., description=\"Human-readable platform name\")\n    vendor: str = Field(..., description=\"Vendor name\")\n    supported: bool = Field(True, description=\"Whether platform is currently supported\")\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.PlatformRules","title":"<code>PlatformRules</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Platform-specific rules and behaviors.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class PlatformRules(BaseModel):\n    \"\"\"Platform-specific rules and behaviors.\"\"\"\n\n    platform_name: str = Field(..., description=\"Platform identifier\")\n    negation_default_when: list[str] = Field(\n        default_factory=list, description=\"Default negation patterns for when conditions\"\n    )\n    negation_negate_with: list[str] = Field(\n        default_factory=list, description=\"How to negate specific commands\"\n    )\n    ordering: list[dict[str, Any]] = Field(\n        default_factory=list, description=\"Command ordering rules\"\n    )\n    idempotent_commands_avoid: list[str] = Field(\n        default_factory=list, description=\"Commands to avoid in idempotent configs\"\n    )\n    idempotent_commands: list[str] = Field(\n        default_factory=list, description=\"Commands that are idempotent\"\n    )\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.ValidateConfigRequest","title":"<code>ValidateConfigRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for validating configuration.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class ValidateConfigRequest(BaseModel):\n    \"\"\"Request model for validating configuration.\"\"\"\n\n    config_text: str = Field(..., description=\"Configuration text to validate\")\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.ValidateConfigResponse","title":"<code>ValidateConfigResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for configuration validation.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class ValidateConfigResponse(BaseModel):\n    \"\"\"Response model for configuration validation.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type\")\n    is_valid: bool = Field(..., description=\"Whether configuration is valid\")\n    warnings: list[str] = Field(default_factory=list, description=\"Validation warnings\")\n    errors: list[str] = Field(default_factory=list, description=\"Validation errors\")\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.BatchJobRequest","title":"<code>BatchJobRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for batch job.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class BatchJobRequest(BaseModel):\n    \"\"\"Request model for batch job.\"\"\"\n\n    device_configs: list[dict[str, Any]] = Field(..., description=\"List of device configurations\")\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.BatchJobResponse","title":"<code>BatchJobResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for batch job creation.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class BatchJobResponse(BaseModel):\n    \"\"\"Response model for batch job creation.\"\"\"\n\n    job_id: str = Field(..., description=\"Unique job identifier\")\n    total_devices: int = Field(..., description=\"Total number of devices in batch\")\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.BatchJobStatus","title":"<code>BatchJobStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status of a batch job.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class BatchJobStatus(BaseModel):\n    \"\"\"Status of a batch job.\"\"\"\n\n    job_id: str = Field(..., description=\"Job identifier\")\n    status: str = Field(..., description=\"Job status (pending, running, completed, failed)\")\n    progress: float = Field(0.0, description=\"Progress percentage (0.0 to 100.0)\", ge=0.0, le=100.0)\n    total_devices: int = Field(..., description=\"Total number of devices\")\n    completed_devices: int = Field(0, description=\"Number of completed devices\")\n    failed_devices: int = Field(0, description=\"Number of failed devices\")\n</code></pre>"},{"location":"reference/models/platform/#hier_config_api.models.platform.BatchJobResults","title":"<code>BatchJobResults</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Results of a completed batch job.</p> Source code in <code>hier_config_api/models/platform.py</code> <pre><code>class BatchJobResults(BaseModel):\n    \"\"\"Results of a completed batch job.\"\"\"\n\n    job_id: str = Field(..., description=\"Job identifier\")\n    status: str = Field(..., description=\"Job status\")\n    results: list[dict[str, Any]] = Field(..., description=\"Results for each device\")\n    summary: dict[str, Any] = Field(..., description=\"Summary statistics\")\n</code></pre>"},{"location":"reference/models/remediation/","title":"remediation","text":""},{"location":"reference/models/remediation/#hier_config_api.models.remediation","title":"<code>remediation</code>","text":"<p>Pydantic models for remediation operations.</p>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.TagRule","title":"<code>TagRule</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Rule for tagging configuration lines.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class TagRule(BaseModel):\n    \"\"\"Rule for tagging configuration lines.\"\"\"\n\n    match_rules: list[str] = Field(..., description=\"List of match patterns\")\n    tags: list[str] = Field(..., description=\"Tags to apply to matching lines\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.RemediationSummary","title":"<code>RemediationSummary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Summary of remediation changes.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class RemediationSummary(BaseModel):\n    \"\"\"Summary of remediation changes.\"\"\"\n\n    additions: int = Field(0, description=\"Number of configuration additions\")\n    deletions: int = Field(0, description=\"Number of configuration deletions\")\n    modifications: int = Field(0, description=\"Number of configuration modifications\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.GenerateRemediationRequest","title":"<code>GenerateRemediationRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for generating remediation.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class GenerateRemediationRequest(BaseModel):\n    \"\"\"Request model for generating remediation.\"\"\"\n\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    running_config: str = Field(..., description=\"Current running configuration\")\n    intended_config: str = Field(..., description=\"Desired configuration state\")\n    tag_rules: list[TagRule] | None = Field(None, description=\"Optional tag rules to apply\")\n    include_tags: list[str] | None = Field(None, description=\"Only include these tags\")\n    exclude_tags: list[str] | None = Field(None, description=\"Exclude these tags\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.GenerateRemediationResponse","title":"<code>GenerateRemediationResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for generated remediation.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class GenerateRemediationResponse(BaseModel):\n    \"\"\"Response model for generated remediation.\"\"\"\n\n    remediation_id: str = Field(..., description=\"Unique identifier for this remediation\")\n    platform: str = Field(..., description=\"Platform type\")\n    remediation_config: str = Field(..., description=\"Commands to achieve desired state\")\n    rollback_config: str = Field(..., description=\"Commands to rollback changes\")\n    summary: RemediationSummary = Field(..., description=\"Summary of changes\")\n    tags: dict[str, list[str]] = Field(default_factory=dict, description=\"Tags applied to commands\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.ApplyTagsRequest","title":"<code>ApplyTagsRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for applying tags to remediation.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class ApplyTagsRequest(BaseModel):\n    \"\"\"Request model for applying tags to remediation.\"\"\"\n\n    tag_rules: list[TagRule] = Field(..., description=\"Tag rules to apply\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.ApplyTagsResponse","title":"<code>ApplyTagsResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for tagged remediation.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class ApplyTagsResponse(BaseModel):\n    \"\"\"Response model for tagged remediation.\"\"\"\n\n    remediation_id: str = Field(..., description=\"Remediation identifier\")\n    remediation_config: str = Field(..., description=\"Tagged remediation configuration\")\n    tags: dict[str, list[str]] = Field(..., description=\"Tags applied to commands\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.FilterRemediationRequest","title":"<code>FilterRemediationRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for filtering remediation by tags.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class FilterRemediationRequest(BaseModel):\n    \"\"\"Request model for filtering remediation by tags.\"\"\"\n\n    include_tags: list[str] | None = Field(None, description=\"Only include these tags\")\n    exclude_tags: list[str] | None = Field(None, description=\"Exclude these tags\")\n</code></pre>"},{"location":"reference/models/remediation/#hier_config_api.models.remediation.FilterRemediationResponse","title":"<code>FilterRemediationResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for filtered remediation.</p> Source code in <code>hier_config_api/models/remediation.py</code> <pre><code>class FilterRemediationResponse(BaseModel):\n    \"\"\"Response model for filtered remediation.\"\"\"\n\n    remediation_id: str = Field(..., description=\"Remediation identifier\")\n    filtered_config: str = Field(..., description=\"Filtered remediation commands\")\n    summary: RemediationSummary = Field(..., description=\"Summary of filtered changes\")\n</code></pre>"},{"location":"reference/models/report/","title":"report","text":""},{"location":"reference/models/report/#hier_config_api.models.report","title":"<code>report</code>","text":"<p>Pydantic models for multi-device reporting.</p>"},{"location":"reference/models/report/#hier_config_api.models.report.DeviceRemediation","title":"<code>DeviceRemediation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for a single device's remediation data.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class DeviceRemediation(BaseModel):\n    \"\"\"Model for a single device's remediation data.\"\"\"\n\n    device_id: str = Field(..., description=\"Unique device identifier\")\n    platform: str = Field(..., description=\"Platform type (e.g., cisco_ios, juniper_junos)\")\n    running_config: str = Field(..., description=\"Current running configuration\")\n    intended_config: str = Field(..., description=\"Desired configuration state\")\n</code></pre>"},{"location":"reference/models/report/#hier_config_api.models.report.CreateReportRequest","title":"<code>CreateReportRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for creating a multi-device report.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class CreateReportRequest(BaseModel):\n    \"\"\"Request model for creating a multi-device report.\"\"\"\n\n    remediations: list[DeviceRemediation] = Field(\n        ..., description=\"List of device remediation data\"\n    )\n</code></pre>"},{"location":"reference/models/report/#hier_config_api.models.report.CreateReportResponse","title":"<code>CreateReportResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for created report.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class CreateReportResponse(BaseModel):\n    \"\"\"Response model for created report.\"\"\"\n\n    report_id: str = Field(..., description=\"Unique report identifier\")\n    total_devices: int = Field(..., description=\"Total number of devices in report\")\n</code></pre>"},{"location":"reference/models/report/#hier_config_api.models.report.ReportSummary","title":"<code>ReportSummary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Summary statistics for a report.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class ReportSummary(BaseModel):\n    \"\"\"Summary statistics for a report.\"\"\"\n\n    total_devices: int = Field(..., description=\"Total number of devices\")\n    devices_with_changes: int = Field(..., description=\"Number of devices with changes\")\n    total_changes: int = Field(..., description=\"Total number of changes across all devices\")\n    changes_by_tag: dict[str, int] = Field(\n        default_factory=dict, description=\"Count of changes by tag\"\n    )\n</code></pre>"},{"location":"reference/models/report/#hier_config_api.models.report.ChangeDetail","title":"<code>ChangeDetail</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Detailed information about a specific change.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class ChangeDetail(BaseModel):\n    \"\"\"Detailed information about a specific change.\"\"\"\n\n    change_text: str = Field(..., description=\"The configuration change text\")\n    device_count: int = Field(..., description=\"Number of devices with this change\")\n    device_ids: list[str] = Field(..., description=\"List of affected device IDs\")\n    tags: list[str] = Field(default_factory=list, description=\"Tags associated with this change\")\n</code></pre>"},{"location":"reference/models/report/#hier_config_api.models.report.GetReportChangesResponse","title":"<code>GetReportChangesResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for detailed change analysis.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class GetReportChangesResponse(BaseModel):\n    \"\"\"Response model for detailed change analysis.\"\"\"\n\n    report_id: str = Field(..., description=\"Report identifier\")\n    changes: list[ChangeDetail] = Field(..., description=\"Detailed list of changes\")\n    total_unique_changes: int = Field(..., description=\"Number of unique changes\")\n</code></pre>"},{"location":"reference/models/report/#hier_config_api.models.report.ExportFormat","title":"<code>ExportFormat</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Supported export formats.</p> Source code in <code>hier_config_api/models/report.py</code> <pre><code>class ExportFormat(BaseModel):\n    \"\"\"Supported export formats.\"\"\"\n\n    format: str = Field(\"json\", description=\"Export format (json, csv, yaml)\")\n</code></pre>"},{"location":"reference/routers/","title":"routers","text":""},{"location":"reference/routers/#hier_config_api.routers","title":"<code>routers</code>","text":""},{"location":"reference/routers/batch/","title":"batch","text":""},{"location":"reference/routers/batch/#hier_config_api.routers.batch","title":"<code>batch</code>","text":"<p>API router for batch operations.</p>"},{"location":"reference/routers/batch/#hier_config_api.routers.batch.create_batch_remediation","title":"<code>create_batch_remediation(request)</code>  <code>async</code>","text":"<p>Create a batch remediation job for multiple devices.</p> Source code in <code>hier_config_api/routers/batch.py</code> <pre><code>@router.post(\"/remediation\", response_model=BatchJobResponse)\nasync def create_batch_remediation(request: BatchJobRequest) -&gt; BatchJobResponse:\n    \"\"\"Create a batch remediation job for multiple devices.\"\"\"\n    try:\n        job_data = PlatformService.create_batch_job(request.device_configs)\n        job_id = storage.store_job(job_data)\n\n        # Process the job (in a real implementation, this would be async/background)\n        PlatformService.process_batch_job(job_data)\n        storage.update_job(job_id, job_data)\n\n        return BatchJobResponse(job_id=job_id, total_devices=job_data[\"total_devices\"])\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to create batch job: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/batch/#hier_config_api.routers.batch.get_batch_job_status","title":"<code>get_batch_job_status(job_id)</code>  <code>async</code>","text":"<p>Get the status of a batch job.</p> Source code in <code>hier_config_api/routers/batch.py</code> <pre><code>@router.get(\"/jobs/{job_id}\", response_model=BatchJobStatus)\nasync def get_batch_job_status(job_id: str) -&gt; BatchJobStatus:\n    \"\"\"Get the status of a batch job.\"\"\"\n    job_data = storage.get_job(job_id)\n    if not job_data:\n        raise HTTPException(status_code=404, detail=\"Job not found\")\n\n    try:\n        return BatchJobStatus(\n            job_id=job_id,\n            status=job_data[\"status\"],\n            progress=job_data[\"progress\"],\n            total_devices=job_data[\"total_devices\"],\n            completed_devices=job_data[\"completed_devices\"],\n            failed_devices=job_data[\"failed_devices\"],\n        )\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to get job status: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/batch/#hier_config_api.routers.batch.get_batch_job_results","title":"<code>get_batch_job_results(job_id)</code>  <code>async</code>","text":"<p>Get the results of a completed batch job.</p> Source code in <code>hier_config_api/routers/batch.py</code> <pre><code>@router.get(\"/jobs/{job_id}/results\", response_model=BatchJobResults)\nasync def get_batch_job_results(job_id: str) -&gt; BatchJobResults:\n    \"\"\"Get the results of a completed batch job.\"\"\"\n    job_data = storage.get_job(job_id)\n    if not job_data:\n        raise HTTPException(status_code=404, detail=\"Job not found\")\n\n    if job_data[\"status\"] not in [\"completed\", \"failed\"]:\n        raise HTTPException(status_code=400, detail=\"Job is not yet completed\")\n\n    try:\n        summary = {\n            \"total_devices\": job_data[\"total_devices\"],\n            \"completed_devices\": job_data[\"completed_devices\"],\n            \"failed_devices\": job_data[\"failed_devices\"],\n            \"status\": job_data[\"status\"],\n        }\n\n        return BatchJobResults(\n            job_id=job_id,\n            status=job_data[\"status\"],\n            results=job_data[\"results\"],\n            summary=summary,\n        )\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to get job results: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/configs/","title":"configs","text":""},{"location":"reference/routers/configs/#hier_config_api.routers.configs","title":"<code>configs</code>","text":"<p>API router for configuration operations.</p>"},{"location":"reference/routers/configs/#hier_config_api.routers.configs.parse_config","title":"<code>parse_config(request)</code>  <code>async</code>","text":"<p>Parse configuration text into structured format.</p> Source code in <code>hier_config_api/routers/configs.py</code> <pre><code>@router.post(\"/parse\", response_model=ParseConfigResponse)\nasync def parse_config(request: ParseConfigRequest) -&gt; ParseConfigResponse:\n    \"\"\"Parse configuration text into structured format.\"\"\"\n    try:\n        structured_config = ConfigService.parse_config(request.platform, request.config_text)\n        return ParseConfigResponse(platform=request.platform, structured_config=structured_config)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to parse config: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/configs/#hier_config_api.routers.configs.compare_configs","title":"<code>compare_configs(request)</code>  <code>async</code>","text":"<p>Compare two configurations and return differences.</p> Source code in <code>hier_config_api/routers/configs.py</code> <pre><code>@router.post(\"/compare\", response_model=CompareConfigResponse)\nasync def compare_configs(request: CompareConfigRequest) -&gt; CompareConfigResponse:\n    \"\"\"Compare two configurations and return differences.\"\"\"\n    try:\n        unified_diff, has_changes = ConfigService.compare_configs(\n            request.platform, request.running_config, request.intended_config\n        )\n        return CompareConfigResponse(\n            platform=request.platform, unified_diff=unified_diff, has_changes=has_changes\n        )\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to compare configs: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/configs/#hier_config_api.routers.configs.predict_config","title":"<code>predict_config(request)</code>  <code>async</code>","text":"<p>Predict future configuration state after applying commands.</p> Source code in <code>hier_config_api/routers/configs.py</code> <pre><code>@router.post(\"/predict\", response_model=PredictConfigResponse)\nasync def predict_config(request: PredictConfigRequest) -&gt; PredictConfigResponse:\n    \"\"\"Predict future configuration state after applying commands.\"\"\"\n    try:\n        predicted_config = ConfigService.predict_config(\n            request.platform, request.current_config, request.commands_to_apply\n        )\n        return PredictConfigResponse(platform=request.platform, predicted_config=predicted_config)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to predict config: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/configs/#hier_config_api.routers.configs.merge_configs","title":"<code>merge_configs(request)</code>  <code>async</code>","text":"<p>Merge multiple configurations into one.</p> Source code in <code>hier_config_api/routers/configs.py</code> <pre><code>@router.post(\"/merge\", response_model=MergeConfigResponse)\nasync def merge_configs(request: MergeConfigRequest) -&gt; MergeConfigResponse:\n    \"\"\"Merge multiple configurations into one.\"\"\"\n    try:\n        merged_config = ConfigService.merge_configs(request.platform, request.configs)\n        return MergeConfigResponse(platform=request.platform, merged_config=merged_config)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to merge configs: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/configs/#hier_config_api.routers.configs.search_config","title":"<code>search_config(request)</code>  <code>async</code>","text":"<p>Search configuration for matching sections.</p> Source code in <code>hier_config_api/routers/configs.py</code> <pre><code>@router.post(\"/search\", response_model=SearchConfigResponse)\nasync def search_config(request: SearchConfigRequest) -&gt; SearchConfigResponse:\n    \"\"\"Search configuration for matching sections.\"\"\"\n    try:\n        matches = ConfigService.search_config(\n            platform=request.platform,\n            config_text=request.config_text,\n            equals=request.match_rules.equals,\n            contains=request.match_rules.contains,\n            startswith=request.match_rules.startswith,\n            regex_pattern=request.match_rules.regex,\n        )\n        return SearchConfigResponse(\n            platform=request.platform, matches=matches, match_count=len(matches)\n        )\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to search config: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/platforms/","title":"platforms","text":""},{"location":"reference/routers/platforms/#hier_config_api.routers.platforms","title":"<code>platforms</code>","text":"<p>API router for platform information.</p>"},{"location":"reference/routers/platforms/#hier_config_api.routers.platforms.list_platforms","title":"<code>list_platforms()</code>  <code>async</code>","text":"<p>List all supported platforms.</p> Source code in <code>hier_config_api/routers/platforms.py</code> <pre><code>@router.get(\"\", response_model=list[PlatformInfo])\nasync def list_platforms() -&gt; list[PlatformInfo]:\n    \"\"\"List all supported platforms.\"\"\"\n    try:\n        return PlatformService.list_platforms()\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to list platforms: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/platforms/#hier_config_api.routers.platforms.get_platform_rules","title":"<code>get_platform_rules(platform)</code>  <code>async</code>","text":"<p>Get platform-specific rules and behaviors.</p> Source code in <code>hier_config_api/routers/platforms.py</code> <pre><code>@router.get(\"/{platform}/rules\", response_model=PlatformRules)\nasync def get_platform_rules(platform: str) -&gt; PlatformRules:\n    \"\"\"Get platform-specific rules and behaviors.\"\"\"\n    try:\n        return PlatformService.get_platform_rules(platform)\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to get platform rules: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/routers/platforms/#hier_config_api.routers.platforms.validate_config","title":"<code>validate_config(platform, request)</code>  <code>async</code>","text":"<p>Validate configuration for a specific platform.</p> Source code in <code>hier_config_api/routers/platforms.py</code> <pre><code>@router.post(\"/{platform}/validate\", response_model=ValidateConfigResponse)\nasync def validate_config(platform: str, request: ValidateConfigRequest) -&gt; ValidateConfigResponse:\n    \"\"\"Validate configuration for a specific platform.\"\"\"\n    try:\n        result = PlatformService.validate_config(platform, request.config_text)\n        return ValidateConfigResponse(**result)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to validate config: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/remediation/","title":"remediation","text":""},{"location":"reference/routers/remediation/#hier_config_api.routers.remediation","title":"<code>remediation</code>","text":"<p>API router for remediation operations.</p>"},{"location":"reference/routers/remediation/#hier_config_api.routers.remediation.generate_remediation","title":"<code>generate_remediation(request)</code>  <code>async</code>","text":"<p>Generate remediation and rollback configurations.</p> Source code in <code>hier_config_api/routers/remediation.py</code> <pre><code>@router.post(\"/generate\", response_model=GenerateRemediationResponse)\nasync def generate_remediation(request: GenerateRemediationRequest) -&gt; GenerateRemediationResponse:\n    \"\"\"Generate remediation and rollback configurations.\"\"\"\n    try:\n        result = RemediationService.generate_remediation(\n            platform=request.platform,\n            running_config=request.running_config,\n            intended_config=request.intended_config,\n            tag_rules=request.tag_rules,\n            include_tags=request.include_tags,\n            exclude_tags=request.exclude_tags,\n        )\n\n        # Store remediation\n        remediation_id = storage.store_remediation(result)\n        result[\"remediation_id\"] = remediation_id\n\n        return GenerateRemediationResponse(\n            remediation_id=remediation_id,\n            platform=result[\"platform\"],\n            remediation_config=result[\"remediation_config\"],\n            rollback_config=result[\"rollback_config\"],\n            summary=result[\"summary\"],\n            tags=result[\"tags\"],\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to generate remediation: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/routers/remediation/#hier_config_api.routers.remediation.apply_tags","title":"<code>apply_tags(remediation_id, request)</code>  <code>async</code>","text":"<p>Apply tags to an existing remediation.</p> Source code in <code>hier_config_api/routers/remediation.py</code> <pre><code>@router.post(\"/{remediation_id}/tags\", response_model=ApplyTagsResponse)\nasync def apply_tags(remediation_id: str, request: ApplyTagsRequest) -&gt; ApplyTagsResponse:\n    \"\"\"Apply tags to an existing remediation.\"\"\"\n    remediation_data = storage.get_remediation(remediation_id)\n    if not remediation_data:\n        raise HTTPException(status_code=404, detail=\"Remediation not found\")\n\n    try:\n        remediation_config = remediation_data[\"remediation_config\"]\n        tagged_config, tags = RemediationService.apply_tags(remediation_config, request.tag_rules)\n\n        # Update stored remediation\n        storage.update_remediation(remediation_id, {\"tags\": tags})\n\n        return ApplyTagsResponse(\n            remediation_id=remediation_id, remediation_config=tagged_config, tags=tags\n        )\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to apply tags: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/remediation/#hier_config_api.routers.remediation.filter_remediation","title":"<code>filter_remediation(remediation_id, include_tags=Query(None), exclude_tags=Query(None))</code>  <code>async</code>","text":"<p>Filter remediation by tags.</p> Source code in <code>hier_config_api/routers/remediation.py</code> <pre><code>@router.get(\"/{remediation_id}/filter\", response_model=FilterRemediationResponse)\nasync def filter_remediation(\n    remediation_id: str,\n    include_tags: list[str] = Query(None),\n    exclude_tags: list[str] = Query(None),\n) -&gt; FilterRemediationResponse:\n    \"\"\"Filter remediation by tags.\"\"\"\n    remediation_data = storage.get_remediation(remediation_id)\n    if not remediation_data:\n        raise HTTPException(status_code=404, detail=\"Remediation not found\")\n\n    try:\n        remediation_config = remediation_data[\"remediation_config\"]\n        tags = remediation_data.get(\"tags\", {})\n\n        filtered_config, summary = RemediationService.filter_remediation(\n            remediation_config, tags, include_tags, exclude_tags\n        )\n\n        return FilterRemediationResponse(\n            remediation_id=remediation_id, filtered_config=filtered_config, summary=summary\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to filter remediation: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/routers/reports/","title":"reports","text":""},{"location":"reference/routers/reports/#hier_config_api.routers.reports","title":"<code>reports</code>","text":"<p>API router for multi-device reporting.</p>"},{"location":"reference/routers/reports/#hier_config_api.routers.reports.create_report","title":"<code>create_report(request)</code>  <code>async</code>","text":"<p>Create a multi-device report.</p> Source code in <code>hier_config_api/routers/reports.py</code> <pre><code>@router.post(\"\", response_model=CreateReportResponse)\nasync def create_report(request: CreateReportRequest) -&gt; CreateReportResponse:\n    \"\"\"Create a multi-device report.\"\"\"\n    try:\n        report_data = ReportService.create_report(request.remediations)\n        report_id = storage.store_report(report_data)\n\n        return CreateReportResponse(report_id=report_id, total_devices=report_data[\"total_devices\"])\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to create report: {str(e)}\") from e\n</code></pre>"},{"location":"reference/routers/reports/#hier_config_api.routers.reports.get_report_summary","title":"<code>get_report_summary(report_id)</code>  <code>async</code>","text":"<p>Get summary statistics for a report.</p> Source code in <code>hier_config_api/routers/reports.py</code> <pre><code>@router.get(\"/{report_id}/summary\", response_model=ReportSummary)\nasync def get_report_summary(report_id: str) -&gt; ReportSummary:\n    \"\"\"Get summary statistics for a report.\"\"\"\n    report_data = storage.get_report(report_id)\n    if not report_data:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    try:\n        return ReportService.get_summary(report_data)\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to get report summary: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/routers/reports/#hier_config_api.routers.reports.get_report_changes","title":"<code>get_report_changes(report_id, tag=Query(None), min_devices=Query(1))</code>  <code>async</code>","text":"<p>Get detailed change analysis for a report.</p> Source code in <code>hier_config_api/routers/reports.py</code> <pre><code>@router.get(\"/{report_id}/changes\", response_model=GetReportChangesResponse)\nasync def get_report_changes(\n    report_id: str, tag: str | None = Query(None), min_devices: int = Query(1)\n) -&gt; GetReportChangesResponse:\n    \"\"\"Get detailed change analysis for a report.\"\"\"\n    report_data = storage.get_report(report_id)\n    if not report_data:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    try:\n        changes = ReportService.get_changes(report_data, tag_filter=tag, min_devices=min_devices)\n\n        return GetReportChangesResponse(\n            report_id=report_id, changes=changes, total_unique_changes=len(changes)\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Failed to get report changes: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/routers/reports/#hier_config_api.routers.reports.export_report","title":"<code>export_report(report_id, format=Query('json'))</code>  <code>async</code>","text":"<p>Export report in specified format (json, csv, yaml).</p> Source code in <code>hier_config_api/routers/reports.py</code> <pre><code>@router.get(\"/{report_id}/export\", response_class=PlainTextResponse)\nasync def export_report(report_id: str, format: str = Query(\"json\")) -&gt; str:\n    \"\"\"Export report in specified format (json, csv, yaml).\"\"\"\n    report_data = storage.get_report(report_id)\n    if not report_data:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    if format not in [\"json\", \"csv\", \"yaml\"]:\n        raise HTTPException(status_code=400, detail=\"Format must be one of: json, csv, yaml\")\n\n    try:\n        return ReportService.export_report(report_data, format_type=format)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Failed to export report: {str(e)}\") from e\n</code></pre>"},{"location":"reference/services/","title":"services","text":""},{"location":"reference/services/#hier_config_api.services","title":"<code>services</code>","text":""},{"location":"reference/services/config_service/","title":"config_service","text":""},{"location":"reference/services/config_service/#hier_config_api.services.config_service","title":"<code>config_service</code>","text":"<p>Service layer for configuration operations.</p>"},{"location":"reference/services/config_service/#hier_config_api.services.config_service.ConfigService","title":"<code>ConfigService</code>","text":"<p>Service for handling configuration operations.</p> Source code in <code>hier_config_api/services/config_service.py</code> <pre><code>class ConfigService:\n    \"\"\"Service for handling configuration operations.\"\"\"\n\n    @staticmethod\n    def _get_platform(platform_str: str) -&gt; Platform:\n        \"\"\"Convert platform string to Platform enum.\"\"\"\n        platform_map = {\n            \"cisco_ios\": Platform.CISCO_IOS,\n            \"cisco_nxos\": Platform.CISCO_NXOS,\n            \"cisco_iosxr\": Platform.CISCO_XR,\n            \"juniper_junos\": Platform.JUNIPER_JUNOS,\n            \"arista_eos\": Platform.ARISTA_EOS,\n            \"generic\": Platform.GENERIC,\n        }\n        return platform_map.get(platform_str.lower(), Platform.GENERIC)\n\n    @staticmethod\n    def parse_config(platform: str, config_text: str) -&gt; dict[str, Any]:\n        \"\"\"Parse configuration text into structured format.\"\"\"\n        platform_enum = ConfigService._get_platform(platform)\n        hconfig = get_hconfig(platform_enum, config_text)\n\n        # Convert HConfig tree to dictionary representation\n        def config_to_dict(config_obj: Any) -&gt; dict[str, Any]:\n            result: dict[str, Any] = {\n                \"text\": str(config_obj),\n                \"children\": [],\n            }\n            if hasattr(config_obj, \"children\"):\n                for child in config_obj.children:\n                    result[\"children\"].append(config_to_dict(child))\n            return result\n\n        return config_to_dict(hconfig)\n\n    @staticmethod\n    def compare_configs(\n        platform: str, running_config: str, intended_config: str\n    ) -&gt; tuple[str, bool]:\n        \"\"\"Compare two configurations and return unified diff.\"\"\"\n        platform_enum = ConfigService._get_platform(platform)\n        running_hconfig = get_hconfig(platform_enum, running_config)\n        intended_hconfig = get_hconfig(platform_enum, intended_config)\n\n        workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n        remediation = workflow.remediation_config\n        rollback = workflow.rollback_config\n\n        diff_lines = []\n\n        # Generate unified diff format\n        if remediation:\n            diff_lines.append(\"--- running_config\")\n            diff_lines.append(\"+++ intended_config\")\n            for line in str(remediation).splitlines():\n                if line.strip():\n                    diff_lines.append(f\"+ {line}\")\n\n        if rollback:\n            for line in str(rollback).splitlines():\n                if line.strip():\n                    diff_lines.append(f\"- {line}\")\n\n        unified_diff = \"\\n\".join(diff_lines) if diff_lines else \"No differences found\"\n        has_changes = bool(diff_lines)\n\n        return unified_diff, has_changes\n\n    @staticmethod\n    def predict_config(platform: str, current_config: str, commands_to_apply: str) -&gt; str:\n        \"\"\"Predict configuration state after applying commands.\"\"\"\n        # Simple merge: append new commands\n        config_lines = current_config.splitlines()\n        command_lines = commands_to_apply.splitlines()\n        predicted_lines = config_lines + command_lines\n\n        return \"\\n\".join(predicted_lines)\n\n    @staticmethod\n    def merge_configs(platform: str, configs: list[str]) -&gt; str:\n        \"\"\"Merge multiple configurations into one.\"\"\"\n        if not configs:\n            return \"\"\n\n        if len(configs) == 1:\n            return configs[0]\n\n        platform_enum = ConfigService._get_platform(platform)\n\n        # Use the first config as base\n        merged = configs[0]\n\n        # Merge each subsequent config\n        for config in configs[1:]:\n            running_hconfig = get_hconfig(platform_enum, merged)\n            intended_hconfig = get_hconfig(platform_enum, config)\n\n            workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n            remediation = workflow.remediation_config\n            if remediation:\n                merged += \"\\n\" + str(remediation)\n\n        return merged\n\n    @staticmethod\n    def search_config(\n        platform: str,\n        config_text: str,\n        equals: str | None = None,\n        contains: str | None = None,\n        startswith: str | None = None,\n        regex_pattern: str | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Search configuration for matching lines.\"\"\"\n        platform_enum = ConfigService._get_platform(platform)\n        hconfig = get_hconfig(platform_enum, config_text)\n\n        matches = []\n\n        def search_recursive(config_obj: Any) -&gt; None:\n            config_line = str(config_obj).strip()\n\n            # Check matching conditions\n            is_match = False\n            if equals and config_line == equals:\n                is_match = True\n            elif contains and contains in config_line:\n                is_match = True\n            elif startswith and config_line.startswith(startswith):\n                is_match = True\n            elif regex_pattern and re.search(regex_pattern, config_line):\n                is_match = True\n\n            if is_match:\n                matches.append(config_line)\n\n            # Recursively search children\n            if hasattr(config_obj, \"children\"):\n                for child in config_obj.children:\n                    search_recursive(child)\n\n        search_recursive(hconfig)\n        return matches\n</code></pre>"},{"location":"reference/services/config_service/#hier_config_api.services.config_service.ConfigService.parse_config","title":"<code>parse_config(platform, config_text)</code>  <code>staticmethod</code>","text":"<p>Parse configuration text into structured format.</p> Source code in <code>hier_config_api/services/config_service.py</code> <pre><code>@staticmethod\ndef parse_config(platform: str, config_text: str) -&gt; dict[str, Any]:\n    \"\"\"Parse configuration text into structured format.\"\"\"\n    platform_enum = ConfigService._get_platform(platform)\n    hconfig = get_hconfig(platform_enum, config_text)\n\n    # Convert HConfig tree to dictionary representation\n    def config_to_dict(config_obj: Any) -&gt; dict[str, Any]:\n        result: dict[str, Any] = {\n            \"text\": str(config_obj),\n            \"children\": [],\n        }\n        if hasattr(config_obj, \"children\"):\n            for child in config_obj.children:\n                result[\"children\"].append(config_to_dict(child))\n        return result\n\n    return config_to_dict(hconfig)\n</code></pre>"},{"location":"reference/services/config_service/#hier_config_api.services.config_service.ConfigService.compare_configs","title":"<code>compare_configs(platform, running_config, intended_config)</code>  <code>staticmethod</code>","text":"<p>Compare two configurations and return unified diff.</p> Source code in <code>hier_config_api/services/config_service.py</code> <pre><code>@staticmethod\ndef compare_configs(\n    platform: str, running_config: str, intended_config: str\n) -&gt; tuple[str, bool]:\n    \"\"\"Compare two configurations and return unified diff.\"\"\"\n    platform_enum = ConfigService._get_platform(platform)\n    running_hconfig = get_hconfig(platform_enum, running_config)\n    intended_hconfig = get_hconfig(platform_enum, intended_config)\n\n    workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n    remediation = workflow.remediation_config\n    rollback = workflow.rollback_config\n\n    diff_lines = []\n\n    # Generate unified diff format\n    if remediation:\n        diff_lines.append(\"--- running_config\")\n        diff_lines.append(\"+++ intended_config\")\n        for line in str(remediation).splitlines():\n            if line.strip():\n                diff_lines.append(f\"+ {line}\")\n\n    if rollback:\n        for line in str(rollback).splitlines():\n            if line.strip():\n                diff_lines.append(f\"- {line}\")\n\n    unified_diff = \"\\n\".join(diff_lines) if diff_lines else \"No differences found\"\n    has_changes = bool(diff_lines)\n\n    return unified_diff, has_changes\n</code></pre>"},{"location":"reference/services/config_service/#hier_config_api.services.config_service.ConfigService.predict_config","title":"<code>predict_config(platform, current_config, commands_to_apply)</code>  <code>staticmethod</code>","text":"<p>Predict configuration state after applying commands.</p> Source code in <code>hier_config_api/services/config_service.py</code> <pre><code>@staticmethod\ndef predict_config(platform: str, current_config: str, commands_to_apply: str) -&gt; str:\n    \"\"\"Predict configuration state after applying commands.\"\"\"\n    # Simple merge: append new commands\n    config_lines = current_config.splitlines()\n    command_lines = commands_to_apply.splitlines()\n    predicted_lines = config_lines + command_lines\n\n    return \"\\n\".join(predicted_lines)\n</code></pre>"},{"location":"reference/services/config_service/#hier_config_api.services.config_service.ConfigService.merge_configs","title":"<code>merge_configs(platform, configs)</code>  <code>staticmethod</code>","text":"<p>Merge multiple configurations into one.</p> Source code in <code>hier_config_api/services/config_service.py</code> <pre><code>@staticmethod\ndef merge_configs(platform: str, configs: list[str]) -&gt; str:\n    \"\"\"Merge multiple configurations into one.\"\"\"\n    if not configs:\n        return \"\"\n\n    if len(configs) == 1:\n        return configs[0]\n\n    platform_enum = ConfigService._get_platform(platform)\n\n    # Use the first config as base\n    merged = configs[0]\n\n    # Merge each subsequent config\n    for config in configs[1:]:\n        running_hconfig = get_hconfig(platform_enum, merged)\n        intended_hconfig = get_hconfig(platform_enum, config)\n\n        workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n        remediation = workflow.remediation_config\n        if remediation:\n            merged += \"\\n\" + str(remediation)\n\n    return merged\n</code></pre>"},{"location":"reference/services/config_service/#hier_config_api.services.config_service.ConfigService.search_config","title":"<code>search_config(platform, config_text, equals=None, contains=None, startswith=None, regex_pattern=None)</code>  <code>staticmethod</code>","text":"<p>Search configuration for matching lines.</p> Source code in <code>hier_config_api/services/config_service.py</code> <pre><code>@staticmethod\ndef search_config(\n    platform: str,\n    config_text: str,\n    equals: str | None = None,\n    contains: str | None = None,\n    startswith: str | None = None,\n    regex_pattern: str | None = None,\n) -&gt; list[str]:\n    \"\"\"Search configuration for matching lines.\"\"\"\n    platform_enum = ConfigService._get_platform(platform)\n    hconfig = get_hconfig(platform_enum, config_text)\n\n    matches = []\n\n    def search_recursive(config_obj: Any) -&gt; None:\n        config_line = str(config_obj).strip()\n\n        # Check matching conditions\n        is_match = False\n        if equals and config_line == equals:\n            is_match = True\n        elif contains and contains in config_line:\n            is_match = True\n        elif startswith and config_line.startswith(startswith):\n            is_match = True\n        elif regex_pattern and re.search(regex_pattern, config_line):\n            is_match = True\n\n        if is_match:\n            matches.append(config_line)\n\n        # Recursively search children\n        if hasattr(config_obj, \"children\"):\n            for child in config_obj.children:\n                search_recursive(child)\n\n    search_recursive(hconfig)\n    return matches\n</code></pre>"},{"location":"reference/services/platform_service/","title":"platform_service","text":""},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service","title":"<code>platform_service</code>","text":"<p>Service layer for platform information and batch operations.</p>"},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service.PlatformService","title":"<code>PlatformService</code>","text":"<p>Service for handling platform-related operations.</p> Source code in <code>hier_config_api/services/platform_service.py</code> <pre><code>class PlatformService:\n    \"\"\"Service for handling platform-related operations.\"\"\"\n\n    # Common platform definitions\n    PLATFORMS = {\n        \"cisco_ios\": PlatformInfo(\n            platform_name=\"cisco_ios\",\n            display_name=\"Cisco IOS\",\n            vendor=\"Cisco\",\n            supported=True,\n        ),\n        \"cisco_nxos\": PlatformInfo(\n            platform_name=\"cisco_nxos\",\n            display_name=\"Cisco NX-OS\",\n            vendor=\"Cisco\",\n            supported=True,\n        ),\n        \"cisco_iosxr\": PlatformInfo(\n            platform_name=\"cisco_iosxr\",\n            display_name=\"Cisco IOS-XR\",\n            vendor=\"Cisco\",\n            supported=True,\n        ),\n        \"juniper_junos\": PlatformInfo(\n            platform_name=\"juniper_junos\",\n            display_name=\"Juniper Junos\",\n            vendor=\"Juniper\",\n            supported=True,\n        ),\n        \"arista_eos\": PlatformInfo(\n            platform_name=\"arista_eos\",\n            display_name=\"Arista EOS\",\n            vendor=\"Arista\",\n            supported=True,\n        ),\n    }\n\n    @staticmethod\n    def list_platforms() -&gt; list[PlatformInfo]:\n        \"\"\"List all supported platforms.\"\"\"\n        return list(PlatformService.PLATFORMS.values())\n\n    @staticmethod\n    def get_platform_rules(platform: str) -&gt; PlatformRules:\n        \"\"\"Get platform-specific rules.\"\"\"\n        # This is a simplified version\n        # In a real implementation, you'd load this from hier_config's driver options\n        return PlatformRules(\n            platform_name=platform,\n            negation_default_when=[],\n            negation_negate_with=[],\n            ordering=[],\n            idempotent_commands_avoid=[],\n            idempotent_commands=[],\n        )\n\n    @staticmethod\n    def _get_platform(platform_str: str) -&gt; Platform:\n        \"\"\"Convert platform string to Platform enum.\"\"\"\n        platform_map = {\n            \"cisco_ios\": Platform.CISCO_IOS,\n            \"cisco_nxos\": Platform.CISCO_NXOS,\n            \"cisco_iosxr\": Platform.CISCO_XR,\n            \"juniper_junos\": Platform.JUNIPER_JUNOS,\n            \"arista_eos\": Platform.ARISTA_EOS,\n            \"generic\": Platform.GENERIC,\n        }\n        return platform_map.get(platform_str.lower(), Platform.GENERIC)\n\n    @staticmethod\n    def validate_config(platform: str, config_text: str) -&gt; dict[str, Any]:\n        \"\"\"Validate configuration for a platform.\"\"\"\n        warnings = []\n        errors = []\n        is_valid = True\n\n        try:\n            # Try to parse the configuration\n            platform_enum = PlatformService._get_platform(platform)\n            get_hconfig(platform_enum, config_text)\n\n            # Basic validation checks\n            if not config_text.strip():\n                warnings.append(\"Configuration is empty\")\n                is_valid = False\n\n            # Platform-specific validation could be added here\n            if platform == \"cisco_ios\":\n                # Check for common Cisco IOS patterns\n                if \"hostname\" not in config_text:\n                    warnings.append(\"No hostname configured\")\n\n        except Exception as e:\n            errors.append(f\"Configuration parsing error: {str(e)}\")\n            is_valid = False\n\n        return {\n            \"platform\": platform,\n            \"is_valid\": is_valid,\n            \"warnings\": warnings,\n            \"errors\": errors,\n        }\n\n    @staticmethod\n    def create_batch_job(device_configs: list[dict[str, Any]]) -&gt; dict[str, Any]:\n        \"\"\"Create a batch remediation job.\"\"\"\n        return {\n            \"status\": \"pending\",\n            \"progress\": 0.0,\n            \"total_devices\": len(device_configs),\n            \"completed_devices\": 0,\n            \"failed_devices\": 0,\n            \"device_configs\": device_configs,\n            \"results\": [],\n        }\n\n    @staticmethod\n    def process_batch_job(job_data: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process a batch job (simplified synchronous version).\"\"\"\n        results = []\n        completed = 0\n        failed = 0\n\n        for device_config in job_data[\"device_configs\"]:\n            try:\n                # Process each device\n                platform = device_config.get(\"platform\", \"cisco_ios\")\n                running_config = device_config.get(\"running_config\", \"\")\n                intended_config = device_config.get(\"intended_config\", \"\")\n\n                platform_enum = PlatformService._get_platform(platform)\n                running_hconfig = get_hconfig(platform_enum, running_config)\n                intended_hconfig = get_hconfig(platform_enum, intended_config)\n\n                workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n                remediation = workflow.remediation_config\n                rollback = workflow.rollback_config\n\n                results.append(\n                    {\n                        \"device_id\": device_config.get(\"device_id\"),\n                        \"status\": \"success\",\n                        \"remediation\": str(remediation) if remediation else \"\",\n                        \"rollback\": str(rollback) if rollback else \"\",\n                    }\n                )\n                completed += 1\n\n            except Exception as e:\n                results.append(\n                    {\n                        \"device_id\": device_config.get(\"device_id\"),\n                        \"status\": \"failed\",\n                        \"error\": str(e),\n                    }\n                )\n                failed += 1\n\n        # Update job data\n        job_data.update(\n            {\n                \"status\": \"completed\",\n                \"progress\": 100.0,\n                \"completed_devices\": completed,\n                \"failed_devices\": failed,\n                \"results\": results,\n            }\n        )\n\n        return job_data\n</code></pre>"},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service.PlatformService.list_platforms","title":"<code>list_platforms()</code>  <code>staticmethod</code>","text":"<p>List all supported platforms.</p> Source code in <code>hier_config_api/services/platform_service.py</code> <pre><code>@staticmethod\ndef list_platforms() -&gt; list[PlatformInfo]:\n    \"\"\"List all supported platforms.\"\"\"\n    return list(PlatformService.PLATFORMS.values())\n</code></pre>"},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service.PlatformService.get_platform_rules","title":"<code>get_platform_rules(platform)</code>  <code>staticmethod</code>","text":"<p>Get platform-specific rules.</p> Source code in <code>hier_config_api/services/platform_service.py</code> <pre><code>@staticmethod\ndef get_platform_rules(platform: str) -&gt; PlatformRules:\n    \"\"\"Get platform-specific rules.\"\"\"\n    # This is a simplified version\n    # In a real implementation, you'd load this from hier_config's driver options\n    return PlatformRules(\n        platform_name=platform,\n        negation_default_when=[],\n        negation_negate_with=[],\n        ordering=[],\n        idempotent_commands_avoid=[],\n        idempotent_commands=[],\n    )\n</code></pre>"},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service.PlatformService.validate_config","title":"<code>validate_config(platform, config_text)</code>  <code>staticmethod</code>","text":"<p>Validate configuration for a platform.</p> Source code in <code>hier_config_api/services/platform_service.py</code> <pre><code>@staticmethod\ndef validate_config(platform: str, config_text: str) -&gt; dict[str, Any]:\n    \"\"\"Validate configuration for a platform.\"\"\"\n    warnings = []\n    errors = []\n    is_valid = True\n\n    try:\n        # Try to parse the configuration\n        platform_enum = PlatformService._get_platform(platform)\n        get_hconfig(platform_enum, config_text)\n\n        # Basic validation checks\n        if not config_text.strip():\n            warnings.append(\"Configuration is empty\")\n            is_valid = False\n\n        # Platform-specific validation could be added here\n        if platform == \"cisco_ios\":\n            # Check for common Cisco IOS patterns\n            if \"hostname\" not in config_text:\n                warnings.append(\"No hostname configured\")\n\n    except Exception as e:\n        errors.append(f\"Configuration parsing error: {str(e)}\")\n        is_valid = False\n\n    return {\n        \"platform\": platform,\n        \"is_valid\": is_valid,\n        \"warnings\": warnings,\n        \"errors\": errors,\n    }\n</code></pre>"},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service.PlatformService.create_batch_job","title":"<code>create_batch_job(device_configs)</code>  <code>staticmethod</code>","text":"<p>Create a batch remediation job.</p> Source code in <code>hier_config_api/services/platform_service.py</code> <pre><code>@staticmethod\ndef create_batch_job(device_configs: list[dict[str, Any]]) -&gt; dict[str, Any]:\n    \"\"\"Create a batch remediation job.\"\"\"\n    return {\n        \"status\": \"pending\",\n        \"progress\": 0.0,\n        \"total_devices\": len(device_configs),\n        \"completed_devices\": 0,\n        \"failed_devices\": 0,\n        \"device_configs\": device_configs,\n        \"results\": [],\n    }\n</code></pre>"},{"location":"reference/services/platform_service/#hier_config_api.services.platform_service.PlatformService.process_batch_job","title":"<code>process_batch_job(job_data)</code>  <code>staticmethod</code>","text":"<p>Process a batch job (simplified synchronous version).</p> Source code in <code>hier_config_api/services/platform_service.py</code> <pre><code>@staticmethod\ndef process_batch_job(job_data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process a batch job (simplified synchronous version).\"\"\"\n    results = []\n    completed = 0\n    failed = 0\n\n    for device_config in job_data[\"device_configs\"]:\n        try:\n            # Process each device\n            platform = device_config.get(\"platform\", \"cisco_ios\")\n            running_config = device_config.get(\"running_config\", \"\")\n            intended_config = device_config.get(\"intended_config\", \"\")\n\n            platform_enum = PlatformService._get_platform(platform)\n            running_hconfig = get_hconfig(platform_enum, running_config)\n            intended_hconfig = get_hconfig(platform_enum, intended_config)\n\n            workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n            remediation = workflow.remediation_config\n            rollback = workflow.rollback_config\n\n            results.append(\n                {\n                    \"device_id\": device_config.get(\"device_id\"),\n                    \"status\": \"success\",\n                    \"remediation\": str(remediation) if remediation else \"\",\n                    \"rollback\": str(rollback) if rollback else \"\",\n                }\n            )\n            completed += 1\n\n        except Exception as e:\n            results.append(\n                {\n                    \"device_id\": device_config.get(\"device_id\"),\n                    \"status\": \"failed\",\n                    \"error\": str(e),\n                }\n            )\n            failed += 1\n\n    # Update job data\n    job_data.update(\n        {\n            \"status\": \"completed\",\n            \"progress\": 100.0,\n            \"completed_devices\": completed,\n            \"failed_devices\": failed,\n            \"results\": results,\n        }\n    )\n\n    return job_data\n</code></pre>"},{"location":"reference/services/remediation_service/","title":"remediation_service","text":""},{"location":"reference/services/remediation_service/#hier_config_api.services.remediation_service","title":"<code>remediation_service</code>","text":"<p>Service layer for remediation operations.</p>"},{"location":"reference/services/remediation_service/#hier_config_api.services.remediation_service.RemediationService","title":"<code>RemediationService</code>","text":"<p>Service for handling remediation operations.</p> Source code in <code>hier_config_api/services/remediation_service.py</code> <pre><code>class RemediationService:\n    \"\"\"Service for handling remediation operations.\"\"\"\n\n    @staticmethod\n    def _get_platform(platform_str: str) -&gt; Platform:\n        \"\"\"Convert platform string to Platform enum.\"\"\"\n        platform_map = {\n            \"cisco_ios\": Platform.CISCO_IOS,\n            \"cisco_nxos\": Platform.CISCO_NXOS,\n            \"cisco_iosxr\": Platform.CISCO_XR,\n            \"juniper_junos\": Platform.JUNIPER_JUNOS,\n            \"arista_eos\": Platform.ARISTA_EOS,\n            \"generic\": Platform.GENERIC,\n        }\n        return platform_map.get(platform_str.lower(), Platform.GENERIC)\n\n    @staticmethod\n    def generate_remediation(\n        platform: str,\n        running_config: str,\n        intended_config: str,\n        tag_rules: list[TagRule] | None = None,\n        include_tags: list[str] | None = None,\n        exclude_tags: list[str] | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Generate remediation and rollback configurations.\"\"\"\n        platform_enum = RemediationService._get_platform(platform)\n        running_hconfig = get_hconfig(platform_enum, running_config)\n        intended_hconfig = get_hconfig(platform_enum, intended_config)\n\n        # Load tag rules if provided\n        if tag_rules:\n            # Convert tag rules to hier_config format\n            # This is simplified - actual implementation would need proper tag loading\n            pass\n\n        # Generate remediation and rollback\n        workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n        remediation = workflow.remediation_config\n        rollback = workflow.rollback_config\n\n        # Calculate summary\n        remediation_lines = str(remediation).splitlines() if remediation else []\n        rollback_lines = str(rollback).splitlines() if rollback else []\n\n        # Count additions, deletions, modifications\n        additions = len([line for line in remediation_lines if line.strip()])\n        deletions = len([line for line in rollback_lines if line.strip()])\n        modifications = 0  # Simplified - would need more logic to detect modifications\n\n        summary = RemediationSummary(\n            additions=additions, deletions=deletions, modifications=modifications\n        )\n\n        # Apply tag filtering if specified\n        filtered_remediation = str(remediation) if remediation else \"\"\n        if include_tags or exclude_tags:\n            # Simplified tag filtering\n            # In a real implementation, you'd filter based on tags\n            pass\n\n        result = {\n            \"remediation_config\": filtered_remediation,\n            \"rollback_config\": str(rollback) if rollback else \"\",\n            \"summary\": summary,\n            \"tags\": {},\n            \"platform\": platform,\n        }\n\n        return result\n\n    @staticmethod\n    def apply_tags(\n        remediation_config: str, tag_rules: list[TagRule]\n    ) -&gt; tuple[str, dict[str, list[str]]]:\n        \"\"\"Apply tags to remediation configuration.\"\"\"\n        # Simplified implementation\n        # In a real implementation, you'd apply tags based on patterns\n        tags: dict[str, list[str]] = {}\n\n        # For each line in remediation, check if it matches any tag rules\n        for rule in tag_rules:\n            for _match_pattern in rule.match_rules:\n                # Check if pattern matches any lines\n                # Add tags to matching lines\n                pass\n\n        return remediation_config, tags\n\n    @staticmethod\n    def filter_remediation(\n        remediation_config: str,\n        tags: dict[str, list[str]],\n        include_tags: list[str] | None = None,\n        exclude_tags: list[str] | None = None,\n    ) -&gt; tuple[str, RemediationSummary]:\n        \"\"\"Filter remediation configuration by tags.\"\"\"\n        lines = remediation_config.splitlines()\n        filtered_lines = []\n\n        for i, line in enumerate(lines):\n            line_tags = tags.get(str(i), [])\n\n            # Check include/exclude logic\n            if include_tags and not any(tag in line_tags for tag in include_tags):\n                continue\n            if exclude_tags and any(tag in line_tags for tag in exclude_tags):\n                continue\n\n            filtered_lines.append(line)\n\n        filtered_config = \"\\n\".join(filtered_lines)\n\n        # Calculate summary\n        summary = RemediationSummary(\n            additions=len(filtered_lines),\n            deletions=0,\n            modifications=0,\n        )\n\n        return filtered_config, summary\n</code></pre>"},{"location":"reference/services/remediation_service/#hier_config_api.services.remediation_service.RemediationService.generate_remediation","title":"<code>generate_remediation(platform, running_config, intended_config, tag_rules=None, include_tags=None, exclude_tags=None)</code>  <code>staticmethod</code>","text":"<p>Generate remediation and rollback configurations.</p> Source code in <code>hier_config_api/services/remediation_service.py</code> <pre><code>@staticmethod\ndef generate_remediation(\n    platform: str,\n    running_config: str,\n    intended_config: str,\n    tag_rules: list[TagRule] | None = None,\n    include_tags: list[str] | None = None,\n    exclude_tags: list[str] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Generate remediation and rollback configurations.\"\"\"\n    platform_enum = RemediationService._get_platform(platform)\n    running_hconfig = get_hconfig(platform_enum, running_config)\n    intended_hconfig = get_hconfig(platform_enum, intended_config)\n\n    # Load tag rules if provided\n    if tag_rules:\n        # Convert tag rules to hier_config format\n        # This is simplified - actual implementation would need proper tag loading\n        pass\n\n    # Generate remediation and rollback\n    workflow = WorkflowRemediation(running_hconfig, intended_hconfig)\n    remediation = workflow.remediation_config\n    rollback = workflow.rollback_config\n\n    # Calculate summary\n    remediation_lines = str(remediation).splitlines() if remediation else []\n    rollback_lines = str(rollback).splitlines() if rollback else []\n\n    # Count additions, deletions, modifications\n    additions = len([line for line in remediation_lines if line.strip()])\n    deletions = len([line for line in rollback_lines if line.strip()])\n    modifications = 0  # Simplified - would need more logic to detect modifications\n\n    summary = RemediationSummary(\n        additions=additions, deletions=deletions, modifications=modifications\n    )\n\n    # Apply tag filtering if specified\n    filtered_remediation = str(remediation) if remediation else \"\"\n    if include_tags or exclude_tags:\n        # Simplified tag filtering\n        # In a real implementation, you'd filter based on tags\n        pass\n\n    result = {\n        \"remediation_config\": filtered_remediation,\n        \"rollback_config\": str(rollback) if rollback else \"\",\n        \"summary\": summary,\n        \"tags\": {},\n        \"platform\": platform,\n    }\n\n    return result\n</code></pre>"},{"location":"reference/services/remediation_service/#hier_config_api.services.remediation_service.RemediationService.apply_tags","title":"<code>apply_tags(remediation_config, tag_rules)</code>  <code>staticmethod</code>","text":"<p>Apply tags to remediation configuration.</p> Source code in <code>hier_config_api/services/remediation_service.py</code> <pre><code>@staticmethod\ndef apply_tags(\n    remediation_config: str, tag_rules: list[TagRule]\n) -&gt; tuple[str, dict[str, list[str]]]:\n    \"\"\"Apply tags to remediation configuration.\"\"\"\n    # Simplified implementation\n    # In a real implementation, you'd apply tags based on patterns\n    tags: dict[str, list[str]] = {}\n\n    # For each line in remediation, check if it matches any tag rules\n    for rule in tag_rules:\n        for _match_pattern in rule.match_rules:\n            # Check if pattern matches any lines\n            # Add tags to matching lines\n            pass\n\n    return remediation_config, tags\n</code></pre>"},{"location":"reference/services/remediation_service/#hier_config_api.services.remediation_service.RemediationService.filter_remediation","title":"<code>filter_remediation(remediation_config, tags, include_tags=None, exclude_tags=None)</code>  <code>staticmethod</code>","text":"<p>Filter remediation configuration by tags.</p> Source code in <code>hier_config_api/services/remediation_service.py</code> <pre><code>@staticmethod\ndef filter_remediation(\n    remediation_config: str,\n    tags: dict[str, list[str]],\n    include_tags: list[str] | None = None,\n    exclude_tags: list[str] | None = None,\n) -&gt; tuple[str, RemediationSummary]:\n    \"\"\"Filter remediation configuration by tags.\"\"\"\n    lines = remediation_config.splitlines()\n    filtered_lines = []\n\n    for i, line in enumerate(lines):\n        line_tags = tags.get(str(i), [])\n\n        # Check include/exclude logic\n        if include_tags and not any(tag in line_tags for tag in include_tags):\n            continue\n        if exclude_tags and any(tag in line_tags for tag in exclude_tags):\n            continue\n\n        filtered_lines.append(line)\n\n    filtered_config = \"\\n\".join(filtered_lines)\n\n    # Calculate summary\n    summary = RemediationSummary(\n        additions=len(filtered_lines),\n        deletions=0,\n        modifications=0,\n    )\n\n    return filtered_config, summary\n</code></pre>"},{"location":"reference/services/report_service/","title":"report_service","text":""},{"location":"reference/services/report_service/#hier_config_api.services.report_service","title":"<code>report_service</code>","text":"<p>Service layer for multi-device reporting.</p>"},{"location":"reference/services/report_service/#hier_config_api.services.report_service.ReportService","title":"<code>ReportService</code>","text":"<p>Service for handling multi-device reports.</p> Source code in <code>hier_config_api/services/report_service.py</code> <pre><code>class ReportService:\n    \"\"\"Service for handling multi-device reports.\"\"\"\n\n    @staticmethod\n    def create_report(remediations: list[DeviceRemediation]) -&gt; dict[str, Any]:\n        \"\"\"Create a report from multiple device remediations.\"\"\"\n        report_data: dict[str, Any] = {\n            \"devices\": [],\n            \"total_devices\": len(remediations),\n            \"devices_with_changes\": 0,\n            \"total_changes\": 0,\n            \"changes_by_tag\": {},\n            \"change_details\": [],\n        }\n\n        # Track changes across devices\n        change_tracker: dict[str, dict[str, Any]] = defaultdict(\n            lambda: {\"count\": 0, \"devices\": [], \"tags\": []}\n        )\n\n        for device_rem in remediations:\n            # Generate remediation for this device\n            remediation_result = RemediationService.generate_remediation(\n                platform=device_rem.platform,\n                running_config=device_rem.running_config,\n                intended_config=device_rem.intended_config,\n            )\n\n            remediation_config = remediation_result[\"remediation_config\"]\n            has_changes = bool(remediation_config.strip())\n\n            if has_changes:\n                report_data[\"devices_with_changes\"] += 1\n\n            # Track changes\n            changes = remediation_config.splitlines()\n            report_data[\"total_changes\"] += len(changes)\n\n            # Store device data\n            device_data = {\n                \"device_id\": device_rem.device_id,\n                \"platform\": device_rem.platform,\n                \"has_changes\": has_changes,\n                \"change_count\": len(changes),\n                \"remediation\": remediation_config,\n                \"rollback\": remediation_result[\"rollback_config\"],\n            }\n            report_data[\"devices\"].append(device_data)\n\n            # Track individual changes\n            for change in changes:\n                if change.strip():\n                    change_tracker[change][\"count\"] += 1\n                    change_tracker[change][\"devices\"].append(device_rem.device_id)\n\n        # Convert change tracker to change details\n        report_data[\"change_details\"] = [\n            {\n                \"change_text\": change_text,\n                \"device_count\": data[\"count\"],\n                \"device_ids\": data[\"devices\"],\n                \"tags\": data[\"tags\"],\n            }\n            for change_text, data in change_tracker.items()\n        ]\n\n        return report_data\n\n    @staticmethod\n    def get_summary(report_data: dict[str, Any]) -&gt; ReportSummary:\n        \"\"\"Get summary statistics from report.\"\"\"\n        return ReportSummary(\n            total_devices=report_data[\"total_devices\"],\n            devices_with_changes=report_data[\"devices_with_changes\"],\n            total_changes=report_data[\"total_changes\"],\n            changes_by_tag=report_data.get(\"changes_by_tag\", {}),\n        )\n\n    @staticmethod\n    def get_changes(\n        report_data: dict[str, Any],\n        tag_filter: str | None = None,\n        min_devices: int = 1,\n    ) -&gt; list[ChangeDetail]:\n        \"\"\"Get detailed change analysis.\"\"\"\n        changes = report_data.get(\"change_details\", [])\n\n        # Filter by tag if specified\n        if tag_filter:\n            changes = [c for c in changes if tag_filter in c.get(\"tags\", [])]\n\n        # Filter by minimum devices\n        changes = [c for c in changes if c[\"device_count\"] &gt;= min_devices]\n\n        # Convert to ChangeDetail objects\n        return [\n            ChangeDetail(\n                change_text=c[\"change_text\"],\n                device_count=c[\"device_count\"],\n                device_ids=c[\"device_ids\"],\n                tags=c.get(\"tags\", []),\n            )\n            for c in changes\n        ]\n\n    @staticmethod\n    def export_report(report_data: dict[str, Any], format_type: str = \"json\") -&gt; str:\n        \"\"\"Export report in specified format.\"\"\"\n        if format_type == \"json\":\n            return json.dumps(report_data, indent=2)\n\n        elif format_type == \"yaml\":\n            return yaml.dump(report_data, default_flow_style=False)\n\n        elif format_type == \"csv\":\n            output = io.StringIO()\n            writer = csv.writer(output)\n\n            # Write header\n            writer.writerow(\n                [\"Device ID\", \"Platform\", \"Has Changes\", \"Change Count\", \"Remediation Summary\"]\n            )\n\n            # Write device rows\n            for device in report_data.get(\"devices\", []):\n                writer.writerow(\n                    [\n                        device[\"device_id\"],\n                        device[\"platform\"],\n                        device[\"has_changes\"],\n                        device[\"change_count\"],\n                        (\n                            device[\"remediation\"][:50] + \"...\"\n                            if len(device[\"remediation\"]) &gt; 50\n                            else device[\"remediation\"]\n                        ),\n                    ]\n                )\n\n            return output.getvalue()\n\n        else:\n            raise ValueError(f\"Unsupported format: {format_type}\")\n</code></pre>"},{"location":"reference/services/report_service/#hier_config_api.services.report_service.ReportService.create_report","title":"<code>create_report(remediations)</code>  <code>staticmethod</code>","text":"<p>Create a report from multiple device remediations.</p> Source code in <code>hier_config_api/services/report_service.py</code> <pre><code>@staticmethod\ndef create_report(remediations: list[DeviceRemediation]) -&gt; dict[str, Any]:\n    \"\"\"Create a report from multiple device remediations.\"\"\"\n    report_data: dict[str, Any] = {\n        \"devices\": [],\n        \"total_devices\": len(remediations),\n        \"devices_with_changes\": 0,\n        \"total_changes\": 0,\n        \"changes_by_tag\": {},\n        \"change_details\": [],\n    }\n\n    # Track changes across devices\n    change_tracker: dict[str, dict[str, Any]] = defaultdict(\n        lambda: {\"count\": 0, \"devices\": [], \"tags\": []}\n    )\n\n    for device_rem in remediations:\n        # Generate remediation for this device\n        remediation_result = RemediationService.generate_remediation(\n            platform=device_rem.platform,\n            running_config=device_rem.running_config,\n            intended_config=device_rem.intended_config,\n        )\n\n        remediation_config = remediation_result[\"remediation_config\"]\n        has_changes = bool(remediation_config.strip())\n\n        if has_changes:\n            report_data[\"devices_with_changes\"] += 1\n\n        # Track changes\n        changes = remediation_config.splitlines()\n        report_data[\"total_changes\"] += len(changes)\n\n        # Store device data\n        device_data = {\n            \"device_id\": device_rem.device_id,\n            \"platform\": device_rem.platform,\n            \"has_changes\": has_changes,\n            \"change_count\": len(changes),\n            \"remediation\": remediation_config,\n            \"rollback\": remediation_result[\"rollback_config\"],\n        }\n        report_data[\"devices\"].append(device_data)\n\n        # Track individual changes\n        for change in changes:\n            if change.strip():\n                change_tracker[change][\"count\"] += 1\n                change_tracker[change][\"devices\"].append(device_rem.device_id)\n\n    # Convert change tracker to change details\n    report_data[\"change_details\"] = [\n        {\n            \"change_text\": change_text,\n            \"device_count\": data[\"count\"],\n            \"device_ids\": data[\"devices\"],\n            \"tags\": data[\"tags\"],\n        }\n        for change_text, data in change_tracker.items()\n    ]\n\n    return report_data\n</code></pre>"},{"location":"reference/services/report_service/#hier_config_api.services.report_service.ReportService.get_summary","title":"<code>get_summary(report_data)</code>  <code>staticmethod</code>","text":"<p>Get summary statistics from report.</p> Source code in <code>hier_config_api/services/report_service.py</code> <pre><code>@staticmethod\ndef get_summary(report_data: dict[str, Any]) -&gt; ReportSummary:\n    \"\"\"Get summary statistics from report.\"\"\"\n    return ReportSummary(\n        total_devices=report_data[\"total_devices\"],\n        devices_with_changes=report_data[\"devices_with_changes\"],\n        total_changes=report_data[\"total_changes\"],\n        changes_by_tag=report_data.get(\"changes_by_tag\", {}),\n    )\n</code></pre>"},{"location":"reference/services/report_service/#hier_config_api.services.report_service.ReportService.get_changes","title":"<code>get_changes(report_data, tag_filter=None, min_devices=1)</code>  <code>staticmethod</code>","text":"<p>Get detailed change analysis.</p> Source code in <code>hier_config_api/services/report_service.py</code> <pre><code>@staticmethod\ndef get_changes(\n    report_data: dict[str, Any],\n    tag_filter: str | None = None,\n    min_devices: int = 1,\n) -&gt; list[ChangeDetail]:\n    \"\"\"Get detailed change analysis.\"\"\"\n    changes = report_data.get(\"change_details\", [])\n\n    # Filter by tag if specified\n    if tag_filter:\n        changes = [c for c in changes if tag_filter in c.get(\"tags\", [])]\n\n    # Filter by minimum devices\n    changes = [c for c in changes if c[\"device_count\"] &gt;= min_devices]\n\n    # Convert to ChangeDetail objects\n    return [\n        ChangeDetail(\n            change_text=c[\"change_text\"],\n            device_count=c[\"device_count\"],\n            device_ids=c[\"device_ids\"],\n            tags=c.get(\"tags\", []),\n        )\n        for c in changes\n    ]\n</code></pre>"},{"location":"reference/services/report_service/#hier_config_api.services.report_service.ReportService.export_report","title":"<code>export_report(report_data, format_type='json')</code>  <code>staticmethod</code>","text":"<p>Export report in specified format.</p> Source code in <code>hier_config_api/services/report_service.py</code> <pre><code>@staticmethod\ndef export_report(report_data: dict[str, Any], format_type: str = \"json\") -&gt; str:\n    \"\"\"Export report in specified format.\"\"\"\n    if format_type == \"json\":\n        return json.dumps(report_data, indent=2)\n\n    elif format_type == \"yaml\":\n        return yaml.dump(report_data, default_flow_style=False)\n\n    elif format_type == \"csv\":\n        output = io.StringIO()\n        writer = csv.writer(output)\n\n        # Write header\n        writer.writerow(\n            [\"Device ID\", \"Platform\", \"Has Changes\", \"Change Count\", \"Remediation Summary\"]\n        )\n\n        # Write device rows\n        for device in report_data.get(\"devices\", []):\n            writer.writerow(\n                [\n                    device[\"device_id\"],\n                    device[\"platform\"],\n                    device[\"has_changes\"],\n                    device[\"change_count\"],\n                    (\n                        device[\"remediation\"][:50] + \"...\"\n                        if len(device[\"remediation\"]) &gt; 50\n                        else device[\"remediation\"]\n                    ),\n                ]\n            )\n\n        return output.getvalue()\n\n    else:\n        raise ValueError(f\"Unsupported format: {format_type}\")\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#hier_config_api.utils","title":"<code>utils</code>","text":""},{"location":"reference/utils/storage/","title":"storage","text":""},{"location":"reference/utils/storage/#hier_config_api.utils.storage","title":"<code>storage</code>","text":"<p>In-memory storage for reports and batch jobs.</p>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage","title":"<code>InMemoryStorage</code>","text":"<p>Simple in-memory storage for reports and jobs.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>class InMemoryStorage:\n    \"\"\"Simple in-memory storage for reports and jobs.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize storage.\"\"\"\n        self._reports: dict[str, dict[str, Any]] = {}\n        self._jobs: dict[str, dict[str, Any]] = {}\n        self._remediations: dict[str, dict[str, Any]] = {}\n\n    def store_report(self, report_data: dict[str, Any]) -&gt; str:\n        \"\"\"Store a report and return its ID.\"\"\"\n        report_id = str(uuid.uuid4())\n        self._reports[report_id] = report_data\n        return report_id\n\n    def get_report(self, report_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"Retrieve a report by ID.\"\"\"\n        return self._reports.get(report_id)\n\n    def store_job(self, job_data: dict[str, Any]) -&gt; str:\n        \"\"\"Store a batch job and return its ID.\"\"\"\n        job_id = str(uuid.uuid4())\n        self._jobs[job_id] = job_data\n        return job_id\n\n    def get_job(self, job_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"Retrieve a batch job by ID.\"\"\"\n        return self._jobs.get(job_id)\n\n    def update_job(self, job_id: str, updates: dict[str, Any]) -&gt; bool:\n        \"\"\"Update a batch job.\"\"\"\n        if job_id in self._jobs:\n            self._jobs[job_id].update(updates)\n            return True\n        return False\n\n    def store_remediation(self, remediation_data: dict[str, Any]) -&gt; str:\n        \"\"\"Store a remediation and return its ID.\"\"\"\n        remediation_id = str(uuid.uuid4())\n        self._remediations[remediation_id] = remediation_data\n        return remediation_id\n\n    def get_remediation(self, remediation_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"Retrieve a remediation by ID.\"\"\"\n        return self._remediations.get(remediation_id)\n\n    def update_remediation(self, remediation_id: str, updates: dict[str, Any]) -&gt; bool:\n        \"\"\"Update a remediation.\"\"\"\n        if remediation_id in self._remediations:\n            self._remediations[remediation_id].update(updates)\n            return True\n        return False\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.__init__","title":"<code>__init__()</code>","text":"<p>Initialize storage.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize storage.\"\"\"\n    self._reports: dict[str, dict[str, Any]] = {}\n    self._jobs: dict[str, dict[str, Any]] = {}\n    self._remediations: dict[str, dict[str, Any]] = {}\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.store_report","title":"<code>store_report(report_data)</code>","text":"<p>Store a report and return its ID.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def store_report(self, report_data: dict[str, Any]) -&gt; str:\n    \"\"\"Store a report and return its ID.\"\"\"\n    report_id = str(uuid.uuid4())\n    self._reports[report_id] = report_data\n    return report_id\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.get_report","title":"<code>get_report(report_id)</code>","text":"<p>Retrieve a report by ID.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def get_report(self, report_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"Retrieve a report by ID.\"\"\"\n    return self._reports.get(report_id)\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.store_job","title":"<code>store_job(job_data)</code>","text":"<p>Store a batch job and return its ID.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def store_job(self, job_data: dict[str, Any]) -&gt; str:\n    \"\"\"Store a batch job and return its ID.\"\"\"\n    job_id = str(uuid.uuid4())\n    self._jobs[job_id] = job_data\n    return job_id\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.get_job","title":"<code>get_job(job_id)</code>","text":"<p>Retrieve a batch job by ID.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def get_job(self, job_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"Retrieve a batch job by ID.\"\"\"\n    return self._jobs.get(job_id)\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.update_job","title":"<code>update_job(job_id, updates)</code>","text":"<p>Update a batch job.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def update_job(self, job_id: str, updates: dict[str, Any]) -&gt; bool:\n    \"\"\"Update a batch job.\"\"\"\n    if job_id in self._jobs:\n        self._jobs[job_id].update(updates)\n        return True\n    return False\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.store_remediation","title":"<code>store_remediation(remediation_data)</code>","text":"<p>Store a remediation and return its ID.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def store_remediation(self, remediation_data: dict[str, Any]) -&gt; str:\n    \"\"\"Store a remediation and return its ID.\"\"\"\n    remediation_id = str(uuid.uuid4())\n    self._remediations[remediation_id] = remediation_data\n    return remediation_id\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.get_remediation","title":"<code>get_remediation(remediation_id)</code>","text":"<p>Retrieve a remediation by ID.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def get_remediation(self, remediation_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"Retrieve a remediation by ID.\"\"\"\n    return self._remediations.get(remediation_id)\n</code></pre>"},{"location":"reference/utils/storage/#hier_config_api.utils.storage.InMemoryStorage.update_remediation","title":"<code>update_remediation(remediation_id, updates)</code>","text":"<p>Update a remediation.</p> Source code in <code>hier_config_api/utils/storage.py</code> <pre><code>def update_remediation(self, remediation_id: str, updates: dict[str, Any]) -&gt; bool:\n    \"\"\"Update a remediation.\"\"\"\n    if remediation_id in self._remediations:\n        self._remediations[remediation_id].update(updates)\n        return True\n    return False\n</code></pre>"}]}